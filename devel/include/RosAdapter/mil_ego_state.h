// Generated by gencpp from file RosAdapter/mil_ego_state.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_MIL_EGO_STATE_H
#define ROSADAPTER_MESSAGE_MIL_EGO_STATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <RosAdapter/object_state.h>

namespace RosAdapter
{
template <class ContainerAllocator>
struct mil_ego_state_
{
  typedef mil_ego_state_<ContainerAllocator> Type;

  mil_ego_state_()
    : sObjectState()
    , u4initSpeed(0.0)
    , u8DistRoadEnd(0.0)
    , u4LightMask(0)
    , u4WheelSpeedFL(0.0)
    , u4WheelSpeedFR(0.0)
    , u4WheelSpeedRL(0.0)
    , u4WheelSpeedRR(0.0)
    , u4MasterCylinderPressure(0.0)
    , u4WheelHeightLF(0.0)
    , u4WheelHeightLR(0.0)
    , u4WheelHeightRF(0.0)
    , u4WheelHeightRR(0.0)
    , u4SteerAngle(0.0)
    , u1objQuantity(0)
    , u1irc_id(0)
    , u1irc_left_id(0)
    , u1irc_right_id(0)
    , u1cipv_id(0)
    , u1lmc_id(0)
    , u1rmc_id(0)
    , u1isReachInitSpeed(0)  {
    }
  mil_ego_state_(const ContainerAllocator& _alloc)
    : sObjectState(_alloc)
    , u4initSpeed(0.0)
    , u8DistRoadEnd(0.0)
    , u4LightMask(0)
    , u4WheelSpeedFL(0.0)
    , u4WheelSpeedFR(0.0)
    , u4WheelSpeedRL(0.0)
    , u4WheelSpeedRR(0.0)
    , u4MasterCylinderPressure(0.0)
    , u4WheelHeightLF(0.0)
    , u4WheelHeightLR(0.0)
    , u4WheelHeightRF(0.0)
    , u4WheelHeightRR(0.0)
    , u4SteerAngle(0.0)
    , u1objQuantity(0)
    , u1irc_id(0)
    , u1irc_left_id(0)
    , u1irc_right_id(0)
    , u1cipv_id(0)
    , u1lmc_id(0)
    , u1rmc_id(0)
    , u1isReachInitSpeed(0)  {
  (void)_alloc;
    }



   typedef  ::RosAdapter::object_state_<ContainerAllocator>  _sObjectState_type;
  _sObjectState_type sObjectState;

   typedef double _u4initSpeed_type;
  _u4initSpeed_type u4initSpeed;

   typedef double _u8DistRoadEnd_type;
  _u8DistRoadEnd_type u8DistRoadEnd;

   typedef uint32_t _u4LightMask_type;
  _u4LightMask_type u4LightMask;

   typedef float _u4WheelSpeedFL_type;
  _u4WheelSpeedFL_type u4WheelSpeedFL;

   typedef float _u4WheelSpeedFR_type;
  _u4WheelSpeedFR_type u4WheelSpeedFR;

   typedef float _u4WheelSpeedRL_type;
  _u4WheelSpeedRL_type u4WheelSpeedRL;

   typedef float _u4WheelSpeedRR_type;
  _u4WheelSpeedRR_type u4WheelSpeedRR;

   typedef float _u4MasterCylinderPressure_type;
  _u4MasterCylinderPressure_type u4MasterCylinderPressure;

   typedef float _u4WheelHeightLF_type;
  _u4WheelHeightLF_type u4WheelHeightLF;

   typedef float _u4WheelHeightLR_type;
  _u4WheelHeightLR_type u4WheelHeightLR;

   typedef float _u4WheelHeightRF_type;
  _u4WheelHeightRF_type u4WheelHeightRF;

   typedef float _u4WheelHeightRR_type;
  _u4WheelHeightRR_type u4WheelHeightRR;

   typedef float _u4SteerAngle_type;
  _u4SteerAngle_type u4SteerAngle;

   typedef uint8_t _u1objQuantity_type;
  _u1objQuantity_type u1objQuantity;

   typedef uint8_t _u1irc_id_type;
  _u1irc_id_type u1irc_id;

   typedef uint8_t _u1irc_left_id_type;
  _u1irc_left_id_type u1irc_left_id;

   typedef uint8_t _u1irc_right_id_type;
  _u1irc_right_id_type u1irc_right_id;

   typedef uint8_t _u1cipv_id_type;
  _u1cipv_id_type u1cipv_id;

   typedef uint8_t _u1lmc_id_type;
  _u1lmc_id_type u1lmc_id;

   typedef uint8_t _u1rmc_id_type;
  _u1rmc_id_type u1rmc_id;

   typedef uint8_t _u1isReachInitSpeed_type;
  _u1isReachInitSpeed_type u1isReachInitSpeed;





  typedef boost::shared_ptr< ::RosAdapter::mil_ego_state_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::mil_ego_state_<ContainerAllocator> const> ConstPtr;

}; // struct mil_ego_state_

typedef ::RosAdapter::mil_ego_state_<std::allocator<void> > mil_ego_state;

typedef boost::shared_ptr< ::RosAdapter::mil_ego_state > mil_ego_statePtr;
typedef boost::shared_ptr< ::RosAdapter::mil_ego_state const> mil_ego_stateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::mil_ego_state_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::mil_ego_state_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::mil_ego_state_<ContainerAllocator1> & lhs, const ::RosAdapter::mil_ego_state_<ContainerAllocator2> & rhs)
{
  return lhs.sObjectState == rhs.sObjectState &&
    lhs.u4initSpeed == rhs.u4initSpeed &&
    lhs.u8DistRoadEnd == rhs.u8DistRoadEnd &&
    lhs.u4LightMask == rhs.u4LightMask &&
    lhs.u4WheelSpeedFL == rhs.u4WheelSpeedFL &&
    lhs.u4WheelSpeedFR == rhs.u4WheelSpeedFR &&
    lhs.u4WheelSpeedRL == rhs.u4WheelSpeedRL &&
    lhs.u4WheelSpeedRR == rhs.u4WheelSpeedRR &&
    lhs.u4MasterCylinderPressure == rhs.u4MasterCylinderPressure &&
    lhs.u4WheelHeightLF == rhs.u4WheelHeightLF &&
    lhs.u4WheelHeightLR == rhs.u4WheelHeightLR &&
    lhs.u4WheelHeightRF == rhs.u4WheelHeightRF &&
    lhs.u4WheelHeightRR == rhs.u4WheelHeightRR &&
    lhs.u4SteerAngle == rhs.u4SteerAngle &&
    lhs.u1objQuantity == rhs.u1objQuantity &&
    lhs.u1irc_id == rhs.u1irc_id &&
    lhs.u1irc_left_id == rhs.u1irc_left_id &&
    lhs.u1irc_right_id == rhs.u1irc_right_id &&
    lhs.u1cipv_id == rhs.u1cipv_id &&
    lhs.u1lmc_id == rhs.u1lmc_id &&
    lhs.u1rmc_id == rhs.u1rmc_id &&
    lhs.u1isReachInitSpeed == rhs.u1isReachInitSpeed;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::mil_ego_state_<ContainerAllocator1> & lhs, const ::RosAdapter::mil_ego_state_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::mil_ego_state_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::mil_ego_state_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::mil_ego_state_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "163aed62265e04fd2e9211889cc3cfd3";
  }

  static const char* value(const ::RosAdapter::mil_ego_state_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x163aed62265e04fdULL;
  static const uint64_t static_value2 = 0x2e9211889cc3cfd3ULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/mil_ego_state";
  }

  static const char* value(const ::RosAdapter::mil_ego_state_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# /** ------ MIL测试主车信息描述包 ------ */\n"
"\n"
"object_state   sObjectState\n"
"float64        u4initSpeed\n"
"float64        u8DistRoadEnd\n"
"uint32         u4LightMask               \n"
"float32        u4WheelSpeedFL\n"
"float32        u4WheelSpeedFR\n"
"float32        u4WheelSpeedRL\n"
"float32        u4WheelSpeedRR\n"
"float32        u4MasterCylinderPressure\n"
"float32        u4WheelHeightLF\n"
"float32        u4WheelHeightLR\n"
"float32        u4WheelHeightRF\n"
"float32        u4WheelHeightRR\n"
"float32        u4SteerAngle\n"
"uint8          u1objQuantity\n"
"uint8          u1irc_id\n"
"uint8          u1irc_left_id\n"
"uint8          u1irc_right_id\n"
"uint8          u1cipv_id\n"
"uint8          u1lmc_id\n"
"uint8          u1rmc_id\n"
"uint8          u1isReachInitSpeed\n"
"================================================================================\n"
"MSG: RosAdapter/object_state\n"
"# /** ------ 对象信息 ------ */\n"
"coord           sSpeed\n"
"coord           sAccel\n"
"geometry        sGeo\n"
"coord           sPos\n"
"string          au1Name\n"
"string          au1ModelFileName\n"
"string          au1ModelName\n"
"float64[]       au8ParamScale\n"
"uint64          u8RoadId\n"
"float64         u8SpeedLimit\n"
"uint32          u4Id\n"
"float32         u4RoadS\n"
"float32         u4RoadT\n"
"float32         u4HdgRel\n"
"float32         u4LaneOffset\n"
"float32         u4TraveledDist\n"
"uint16          u2visMask\n"
"uint8           u1Type\n"
"int8            u1LaneId\n"
"uint8           u1Dir\n"
"bool            u1IsOnRoad\n"
"uint8           u1category\n"
"================================================================================\n"
"MSG: RosAdapter/coord\n"
"# /** ------ 坐标 ------ */\n"
"float64   u8X\n"
"float64   u8Y\n"
"float64   u8Z\n"
"float32   u4H\n"
"float32   u4P\n"
"float32   u4R\n"
"uint8     u1Type\n"
"================================================================================\n"
"MSG: RosAdapter/geometry\n"
"# /** ------ 几何信息 ------ */\n"
"float32 u4DimX\n"
"float32 u4DimY\n"
"float32 u4DimZ\n"
"float32 u4OffX\n"
"float32 u4OffY\n"
"float32 u4OffZ\n"
;
  }

  static const char* value(const ::RosAdapter::mil_ego_state_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.sObjectState);
      stream.next(m.u4initSpeed);
      stream.next(m.u8DistRoadEnd);
      stream.next(m.u4LightMask);
      stream.next(m.u4WheelSpeedFL);
      stream.next(m.u4WheelSpeedFR);
      stream.next(m.u4WheelSpeedRL);
      stream.next(m.u4WheelSpeedRR);
      stream.next(m.u4MasterCylinderPressure);
      stream.next(m.u4WheelHeightLF);
      stream.next(m.u4WheelHeightLR);
      stream.next(m.u4WheelHeightRF);
      stream.next(m.u4WheelHeightRR);
      stream.next(m.u4SteerAngle);
      stream.next(m.u1objQuantity);
      stream.next(m.u1irc_id);
      stream.next(m.u1irc_left_id);
      stream.next(m.u1irc_right_id);
      stream.next(m.u1cipv_id);
      stream.next(m.u1lmc_id);
      stream.next(m.u1rmc_id);
      stream.next(m.u1isReachInitSpeed);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mil_ego_state_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::mil_ego_state_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::mil_ego_state_<ContainerAllocator>& v)
  {
    s << indent << "sObjectState: ";
    s << std::endl;
    Printer< ::RosAdapter::object_state_<ContainerAllocator> >::stream(s, indent + "  ", v.sObjectState);
    s << indent << "u4initSpeed: ";
    Printer<double>::stream(s, indent + "  ", v.u4initSpeed);
    s << indent << "u8DistRoadEnd: ";
    Printer<double>::stream(s, indent + "  ", v.u8DistRoadEnd);
    s << indent << "u4LightMask: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u4LightMask);
    s << indent << "u4WheelSpeedFL: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelSpeedFL);
    s << indent << "u4WheelSpeedFR: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelSpeedFR);
    s << indent << "u4WheelSpeedRL: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelSpeedRL);
    s << indent << "u4WheelSpeedRR: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelSpeedRR);
    s << indent << "u4MasterCylinderPressure: ";
    Printer<float>::stream(s, indent + "  ", v.u4MasterCylinderPressure);
    s << indent << "u4WheelHeightLF: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelHeightLF);
    s << indent << "u4WheelHeightLR: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelHeightLR);
    s << indent << "u4WheelHeightRF: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelHeightRF);
    s << indent << "u4WheelHeightRR: ";
    Printer<float>::stream(s, indent + "  ", v.u4WheelHeightRR);
    s << indent << "u4SteerAngle: ";
    Printer<float>::stream(s, indent + "  ", v.u4SteerAngle);
    s << indent << "u1objQuantity: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1objQuantity);
    s << indent << "u1irc_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1irc_id);
    s << indent << "u1irc_left_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1irc_left_id);
    s << indent << "u1irc_right_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1irc_right_id);
    s << indent << "u1cipv_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1cipv_id);
    s << indent << "u1lmc_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1lmc_id);
    s << indent << "u1rmc_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1rmc_id);
    s << indent << "u1isReachInitSpeed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1isReachInitSpeed);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_MIL_EGO_STATE_H
