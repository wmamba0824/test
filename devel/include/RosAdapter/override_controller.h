// Generated by gencpp from file RosAdapter/override_controller.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_OVERRIDE_CONTROLLER_H
#define ROSADAPTER_MESSAGE_OVERRIDE_CONTROLLER_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace RosAdapter
{
template <class ContainerAllocator>
struct override_controller_
{
  typedef override_controller_<ContainerAllocator> Type;

  override_controller_()
    : u8ThrottleValue(0.0)
    , u8BrakeValue(0.0)
    , u8SteeringWheelValue(0.0)
    , u8ParkingBrakeValue(0.0)
    , u8ClutchValue(0.0)
    , u8GearValue(0.0)
    , u4ObjectId(0)
    , u1ThrottleActive(false)
    , u1BrakeActive(false)
    , u1SteeringWheelActive(false)
    , u1ParkingBrakeActive(false)
    , u1ClutchActive(false)
    , u1GearActive(false)  {
    }
  override_controller_(const ContainerAllocator& _alloc)
    : u8ThrottleValue(0.0)
    , u8BrakeValue(0.0)
    , u8SteeringWheelValue(0.0)
    , u8ParkingBrakeValue(0.0)
    , u8ClutchValue(0.0)
    , u8GearValue(0.0)
    , u4ObjectId(0)
    , u1ThrottleActive(false)
    , u1BrakeActive(false)
    , u1SteeringWheelActive(false)
    , u1ParkingBrakeActive(false)
    , u1ClutchActive(false)
    , u1GearActive(false)  {
  (void)_alloc;
    }



   typedef double _u8ThrottleValue_type;
  _u8ThrottleValue_type u8ThrottleValue;

   typedef double _u8BrakeValue_type;
  _u8BrakeValue_type u8BrakeValue;

   typedef double _u8SteeringWheelValue_type;
  _u8SteeringWheelValue_type u8SteeringWheelValue;

   typedef double _u8ParkingBrakeValue_type;
  _u8ParkingBrakeValue_type u8ParkingBrakeValue;

   typedef double _u8ClutchValue_type;
  _u8ClutchValue_type u8ClutchValue;

   typedef double _u8GearValue_type;
  _u8GearValue_type u8GearValue;

   typedef uint32_t _u4ObjectId_type;
  _u4ObjectId_type u4ObjectId;

   typedef uint8_t _u1ThrottleActive_type;
  _u1ThrottleActive_type u1ThrottleActive;

   typedef uint8_t _u1BrakeActive_type;
  _u1BrakeActive_type u1BrakeActive;

   typedef uint8_t _u1SteeringWheelActive_type;
  _u1SteeringWheelActive_type u1SteeringWheelActive;

   typedef uint8_t _u1ParkingBrakeActive_type;
  _u1ParkingBrakeActive_type u1ParkingBrakeActive;

   typedef uint8_t _u1ClutchActive_type;
  _u1ClutchActive_type u1ClutchActive;

   typedef uint8_t _u1GearActive_type;
  _u1GearActive_type u1GearActive;





  typedef boost::shared_ptr< ::RosAdapter::override_controller_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::override_controller_<ContainerAllocator> const> ConstPtr;

}; // struct override_controller_

typedef ::RosAdapter::override_controller_<std::allocator<void> > override_controller;

typedef boost::shared_ptr< ::RosAdapter::override_controller > override_controllerPtr;
typedef boost::shared_ptr< ::RosAdapter::override_controller const> override_controllerConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::override_controller_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::override_controller_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::override_controller_<ContainerAllocator1> & lhs, const ::RosAdapter::override_controller_<ContainerAllocator2> & rhs)
{
  return lhs.u8ThrottleValue == rhs.u8ThrottleValue &&
    lhs.u8BrakeValue == rhs.u8BrakeValue &&
    lhs.u8SteeringWheelValue == rhs.u8SteeringWheelValue &&
    lhs.u8ParkingBrakeValue == rhs.u8ParkingBrakeValue &&
    lhs.u8ClutchValue == rhs.u8ClutchValue &&
    lhs.u8GearValue == rhs.u8GearValue &&
    lhs.u4ObjectId == rhs.u4ObjectId &&
    lhs.u1ThrottleActive == rhs.u1ThrottleActive &&
    lhs.u1BrakeActive == rhs.u1BrakeActive &&
    lhs.u1SteeringWheelActive == rhs.u1SteeringWheelActive &&
    lhs.u1ParkingBrakeActive == rhs.u1ParkingBrakeActive &&
    lhs.u1ClutchActive == rhs.u1ClutchActive &&
    lhs.u1GearActive == rhs.u1GearActive;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::override_controller_<ContainerAllocator1> & lhs, const ::RosAdapter::override_controller_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::override_controller_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::override_controller_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::override_controller_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::override_controller_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::override_controller_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::override_controller_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::override_controller_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8ea5a19cb588ee701c9b5157e9aab0b5";
  }

  static const char* value(const ::RosAdapter::override_controller_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8ea5a19cb588ee70ULL;
  static const uint64_t static_value2 = 0x1c9b5157e9aab0b5ULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::override_controller_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/override_controller";
  }

  static const char* value(const ::RosAdapter::override_controller_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::override_controller_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# /** ------接管控制器 ------ */\n"
"\n"
"float64   u8ThrottleValue\n"
"float64   u8BrakeValue\n"
"float64   u8SteeringWheelValue\n"
"float64   u8ParkingBrakeValue\n"
"float64   u8ClutchValue\n"
"float64   u8GearValue\n"
"uint32    u4ObjectId\n"
"bool      u1ThrottleActive\n"
"bool      u1BrakeActive\n"
"bool      u1SteeringWheelActive\n"
"bool      u1ParkingBrakeActive\n"
"bool      u1ClutchActive\n"
"bool      u1GearActive\n"
;
  }

  static const char* value(const ::RosAdapter::override_controller_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::override_controller_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.u8ThrottleValue);
      stream.next(m.u8BrakeValue);
      stream.next(m.u8SteeringWheelValue);
      stream.next(m.u8ParkingBrakeValue);
      stream.next(m.u8ClutchValue);
      stream.next(m.u8GearValue);
      stream.next(m.u4ObjectId);
      stream.next(m.u1ThrottleActive);
      stream.next(m.u1BrakeActive);
      stream.next(m.u1SteeringWheelActive);
      stream.next(m.u1ParkingBrakeActive);
      stream.next(m.u1ClutchActive);
      stream.next(m.u1GearActive);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct override_controller_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::override_controller_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::override_controller_<ContainerAllocator>& v)
  {
    s << indent << "u8ThrottleValue: ";
    Printer<double>::stream(s, indent + "  ", v.u8ThrottleValue);
    s << indent << "u8BrakeValue: ";
    Printer<double>::stream(s, indent + "  ", v.u8BrakeValue);
    s << indent << "u8SteeringWheelValue: ";
    Printer<double>::stream(s, indent + "  ", v.u8SteeringWheelValue);
    s << indent << "u8ParkingBrakeValue: ";
    Printer<double>::stream(s, indent + "  ", v.u8ParkingBrakeValue);
    s << indent << "u8ClutchValue: ";
    Printer<double>::stream(s, indent + "  ", v.u8ClutchValue);
    s << indent << "u8GearValue: ";
    Printer<double>::stream(s, indent + "  ", v.u8GearValue);
    s << indent << "u4ObjectId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u4ObjectId);
    s << indent << "u1ThrottleActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1ThrottleActive);
    s << indent << "u1BrakeActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1BrakeActive);
    s << indent << "u1SteeringWheelActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1SteeringWheelActive);
    s << indent << "u1ParkingBrakeActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1ParkingBrakeActive);
    s << indent << "u1ClutchActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1ClutchActive);
    s << indent << "u1GearActive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1GearActive);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_OVERRIDE_CONTROLLER_H
