// Generated by gencpp from file RosAdapter/object_state.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_OBJECT_STATE_H
#define ROSADAPTER_MESSAGE_OBJECT_STATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <RosAdapter/coord.h>
#include <RosAdapter/coord.h>
#include <RosAdapter/geometry.h>
#include <RosAdapter/coord.h>

namespace RosAdapter
{
template <class ContainerAllocator>
struct object_state_
{
  typedef object_state_<ContainerAllocator> Type;

  object_state_()
    : sSpeed()
    , sAccel()
    , sGeo()
    , sPos()
    , au1Name()
    , au1ModelFileName()
    , au1ModelName()
    , au8ParamScale()
    , u8RoadId(0)
    , u8SpeedLimit(0.0)
    , u4Id(0)
    , u4RoadS(0.0)
    , u4RoadT(0.0)
    , u4HdgRel(0.0)
    , u4LaneOffset(0.0)
    , u4TraveledDist(0.0)
    , u2visMask(0)
    , u1Type(0)
    , u1LaneId(0)
    , u1Dir(0)
    , u1IsOnRoad(false)
    , u1category(0)  {
    }
  object_state_(const ContainerAllocator& _alloc)
    : sSpeed(_alloc)
    , sAccel(_alloc)
    , sGeo(_alloc)
    , sPos(_alloc)
    , au1Name(_alloc)
    , au1ModelFileName(_alloc)
    , au1ModelName(_alloc)
    , au8ParamScale(_alloc)
    , u8RoadId(0)
    , u8SpeedLimit(0.0)
    , u4Id(0)
    , u4RoadS(0.0)
    , u4RoadT(0.0)
    , u4HdgRel(0.0)
    , u4LaneOffset(0.0)
    , u4TraveledDist(0.0)
    , u2visMask(0)
    , u1Type(0)
    , u1LaneId(0)
    , u1Dir(0)
    , u1IsOnRoad(false)
    , u1category(0)  {
  (void)_alloc;
    }



   typedef  ::RosAdapter::coord_<ContainerAllocator>  _sSpeed_type;
  _sSpeed_type sSpeed;

   typedef  ::RosAdapter::coord_<ContainerAllocator>  _sAccel_type;
  _sAccel_type sAccel;

   typedef  ::RosAdapter::geometry_<ContainerAllocator>  _sGeo_type;
  _sGeo_type sGeo;

   typedef  ::RosAdapter::coord_<ContainerAllocator>  _sPos_type;
  _sPos_type sPos;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _au1Name_type;
  _au1Name_type au1Name;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _au1ModelFileName_type;
  _au1ModelFileName_type au1ModelFileName;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _au1ModelName_type;
  _au1ModelName_type au1ModelName;

   typedef std::vector<double, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<double>> _au8ParamScale_type;
  _au8ParamScale_type au8ParamScale;

   typedef uint64_t _u8RoadId_type;
  _u8RoadId_type u8RoadId;

   typedef double _u8SpeedLimit_type;
  _u8SpeedLimit_type u8SpeedLimit;

   typedef uint32_t _u4Id_type;
  _u4Id_type u4Id;

   typedef float _u4RoadS_type;
  _u4RoadS_type u4RoadS;

   typedef float _u4RoadT_type;
  _u4RoadT_type u4RoadT;

   typedef float _u4HdgRel_type;
  _u4HdgRel_type u4HdgRel;

   typedef float _u4LaneOffset_type;
  _u4LaneOffset_type u4LaneOffset;

   typedef float _u4TraveledDist_type;
  _u4TraveledDist_type u4TraveledDist;

   typedef uint16_t _u2visMask_type;
  _u2visMask_type u2visMask;

   typedef uint8_t _u1Type_type;
  _u1Type_type u1Type;

   typedef int8_t _u1LaneId_type;
  _u1LaneId_type u1LaneId;

   typedef uint8_t _u1Dir_type;
  _u1Dir_type u1Dir;

   typedef uint8_t _u1IsOnRoad_type;
  _u1IsOnRoad_type u1IsOnRoad;

   typedef uint8_t _u1category_type;
  _u1category_type u1category;





  typedef boost::shared_ptr< ::RosAdapter::object_state_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::object_state_<ContainerAllocator> const> ConstPtr;

}; // struct object_state_

typedef ::RosAdapter::object_state_<std::allocator<void> > object_state;

typedef boost::shared_ptr< ::RosAdapter::object_state > object_statePtr;
typedef boost::shared_ptr< ::RosAdapter::object_state const> object_stateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::object_state_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::object_state_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::object_state_<ContainerAllocator1> & lhs, const ::RosAdapter::object_state_<ContainerAllocator2> & rhs)
{
  return lhs.sSpeed == rhs.sSpeed &&
    lhs.sAccel == rhs.sAccel &&
    lhs.sGeo == rhs.sGeo &&
    lhs.sPos == rhs.sPos &&
    lhs.au1Name == rhs.au1Name &&
    lhs.au1ModelFileName == rhs.au1ModelFileName &&
    lhs.au1ModelName == rhs.au1ModelName &&
    lhs.au8ParamScale == rhs.au8ParamScale &&
    lhs.u8RoadId == rhs.u8RoadId &&
    lhs.u8SpeedLimit == rhs.u8SpeedLimit &&
    lhs.u4Id == rhs.u4Id &&
    lhs.u4RoadS == rhs.u4RoadS &&
    lhs.u4RoadT == rhs.u4RoadT &&
    lhs.u4HdgRel == rhs.u4HdgRel &&
    lhs.u4LaneOffset == rhs.u4LaneOffset &&
    lhs.u4TraveledDist == rhs.u4TraveledDist &&
    lhs.u2visMask == rhs.u2visMask &&
    lhs.u1Type == rhs.u1Type &&
    lhs.u1LaneId == rhs.u1LaneId &&
    lhs.u1Dir == rhs.u1Dir &&
    lhs.u1IsOnRoad == rhs.u1IsOnRoad &&
    lhs.u1category == rhs.u1category;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::object_state_<ContainerAllocator1> & lhs, const ::RosAdapter::object_state_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::object_state_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::object_state_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::object_state_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::object_state_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::object_state_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::object_state_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::object_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "487cbf303de88174ac14ecc4b4a926e9";
  }

  static const char* value(const ::RosAdapter::object_state_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x487cbf303de88174ULL;
  static const uint64_t static_value2 = 0xac14ecc4b4a926e9ULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::object_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/object_state";
  }

  static const char* value(const ::RosAdapter::object_state_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::object_state_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# /** ------ 对象信息 ------ */\n"
"coord           sSpeed\n"
"coord           sAccel\n"
"geometry        sGeo\n"
"coord           sPos\n"
"string          au1Name\n"
"string          au1ModelFileName\n"
"string          au1ModelName\n"
"float64[]       au8ParamScale\n"
"uint64          u8RoadId\n"
"float64         u8SpeedLimit\n"
"uint32          u4Id\n"
"float32         u4RoadS\n"
"float32         u4RoadT\n"
"float32         u4HdgRel\n"
"float32         u4LaneOffset\n"
"float32         u4TraveledDist\n"
"uint16          u2visMask\n"
"uint8           u1Type\n"
"int8            u1LaneId\n"
"uint8           u1Dir\n"
"bool            u1IsOnRoad\n"
"uint8           u1category\n"
"================================================================================\n"
"MSG: RosAdapter/coord\n"
"# /** ------ 坐标 ------ */\n"
"float64   u8X\n"
"float64   u8Y\n"
"float64   u8Z\n"
"float32   u4H\n"
"float32   u4P\n"
"float32   u4R\n"
"uint8     u1Type\n"
"================================================================================\n"
"MSG: RosAdapter/geometry\n"
"# /** ------ 几何信息 ------ */\n"
"float32 u4DimX\n"
"float32 u4DimY\n"
"float32 u4DimZ\n"
"float32 u4OffX\n"
"float32 u4OffY\n"
"float32 u4OffZ\n"
;
  }

  static const char* value(const ::RosAdapter::object_state_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::object_state_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.sSpeed);
      stream.next(m.sAccel);
      stream.next(m.sGeo);
      stream.next(m.sPos);
      stream.next(m.au1Name);
      stream.next(m.au1ModelFileName);
      stream.next(m.au1ModelName);
      stream.next(m.au8ParamScale);
      stream.next(m.u8RoadId);
      stream.next(m.u8SpeedLimit);
      stream.next(m.u4Id);
      stream.next(m.u4RoadS);
      stream.next(m.u4RoadT);
      stream.next(m.u4HdgRel);
      stream.next(m.u4LaneOffset);
      stream.next(m.u4TraveledDist);
      stream.next(m.u2visMask);
      stream.next(m.u1Type);
      stream.next(m.u1LaneId);
      stream.next(m.u1Dir);
      stream.next(m.u1IsOnRoad);
      stream.next(m.u1category);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct object_state_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::object_state_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::object_state_<ContainerAllocator>& v)
  {
    s << indent << "sSpeed: ";
    s << std::endl;
    Printer< ::RosAdapter::coord_<ContainerAllocator> >::stream(s, indent + "  ", v.sSpeed);
    s << indent << "sAccel: ";
    s << std::endl;
    Printer< ::RosAdapter::coord_<ContainerAllocator> >::stream(s, indent + "  ", v.sAccel);
    s << indent << "sGeo: ";
    s << std::endl;
    Printer< ::RosAdapter::geometry_<ContainerAllocator> >::stream(s, indent + "  ", v.sGeo);
    s << indent << "sPos: ";
    s << std::endl;
    Printer< ::RosAdapter::coord_<ContainerAllocator> >::stream(s, indent + "  ", v.sPos);
    s << indent << "au1Name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.au1Name);
    s << indent << "au1ModelFileName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.au1ModelFileName);
    s << indent << "au1ModelName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.au1ModelName);
    s << indent << "au8ParamScale[]" << std::endl;
    for (size_t i = 0; i < v.au8ParamScale.size(); ++i)
    {
      s << indent << "  au8ParamScale[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.au8ParamScale[i]);
    }
    s << indent << "u8RoadId: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.u8RoadId);
    s << indent << "u8SpeedLimit: ";
    Printer<double>::stream(s, indent + "  ", v.u8SpeedLimit);
    s << indent << "u4Id: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u4Id);
    s << indent << "u4RoadS: ";
    Printer<float>::stream(s, indent + "  ", v.u4RoadS);
    s << indent << "u4RoadT: ";
    Printer<float>::stream(s, indent + "  ", v.u4RoadT);
    s << indent << "u4HdgRel: ";
    Printer<float>::stream(s, indent + "  ", v.u4HdgRel);
    s << indent << "u4LaneOffset: ";
    Printer<float>::stream(s, indent + "  ", v.u4LaneOffset);
    s << indent << "u4TraveledDist: ";
    Printer<float>::stream(s, indent + "  ", v.u4TraveledDist);
    s << indent << "u2visMask: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.u2visMask);
    s << indent << "u1Type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1Type);
    s << indent << "u1LaneId: ";
    Printer<int8_t>::stream(s, indent + "  ", v.u1LaneId);
    s << indent << "u1Dir: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1Dir);
    s << indent << "u1IsOnRoad: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1IsOnRoad);
    s << indent << "u1category: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1category);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_OBJECT_STATE_H
