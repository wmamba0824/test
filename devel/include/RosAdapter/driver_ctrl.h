// Generated by gencpp from file RosAdapter/driver_ctrl.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_DRIVER_CTRL_H
#define ROSADAPTER_MESSAGE_DRIVER_CTRL_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace RosAdapter
{
template <class ContainerAllocator>
struct driver_ctrl_
{
  typedef driver_ctrl_<ContainerAllocator> Type;

  driver_ctrl_()
    : u4ObjectId(0)
    , u4MtWheel(0.0)
    , u8MasterCylinderPressure(0.0)
    , u8SteeringWheel(0.0)
    , u8ThrottlePedal(0.0)
    , u8BrakePedal(0.0)
    , u8AccelTgt(0.0)
    , u8SteeringTorque(0.0)
    , u8StopDistance(0.0)
    , u8TargetSpeed(0.0)
    , u8Vx(0.0)
    , u8Wr(0.0)
    , u8VLFWheelSpd(0.0)
    , u8VRFWheelSpd(0.0)
    , u8VLRWheelSpd(0.0)
    , u8VRRWheelSpd(0.0)
    , u8Ax(0.0)
    , u8Ay(0.0)
    , u8SteeringWheelAngularRate(0.0)
    , u8DrvTorqAct(0.0)
    , u8Xmc(0.0)
    , u8Ymc(0.0)
    , u8YawThetaVehicle(0.0)
    , u8PitchThetaVehicle(0.0)
    , u8RollThetaVehicle(0.0)
    , u8PitchRateVehicle(0.0)
    , u8RollRateVehicle(0.0)
    , u8SinSlopeout(0.0)
    , u8VehicleCurv(0.0)
    , u8TmotorCmd(0.0)
    , u8Tmotor(0.0)
    , u8EnergySourceLevel(0.0)
    , u8WLFWheelSpd(0.0)
    , u8WRFWheelSpd(0.0)
    , u8WLRWheelSpd(0.0)
    , u8WRRWheelSpd(0.0)
    , u8WGearSpd(0.0)
    , u1LFWheelRotatedDir(0)
    , u1LRWheelRotatedDir(0)
    , u1RFWheelRotatedDir(0)
    , u1RRWheelRotatedDir(0)
    , u1BrakePedalStatus(0)
    , u1VehicleDir(0)
    , u1BrkType(0)
    , u1Gear(0)  {
    }
  driver_ctrl_(const ContainerAllocator& _alloc)
    : u4ObjectId(0)
    , u4MtWheel(0.0)
    , u8MasterCylinderPressure(0.0)
    , u8SteeringWheel(0.0)
    , u8ThrottlePedal(0.0)
    , u8BrakePedal(0.0)
    , u8AccelTgt(0.0)
    , u8SteeringTorque(0.0)
    , u8StopDistance(0.0)
    , u8TargetSpeed(0.0)
    , u8Vx(0.0)
    , u8Wr(0.0)
    , u8VLFWheelSpd(0.0)
    , u8VRFWheelSpd(0.0)
    , u8VLRWheelSpd(0.0)
    , u8VRRWheelSpd(0.0)
    , u8Ax(0.0)
    , u8Ay(0.0)
    , u8SteeringWheelAngularRate(0.0)
    , u8DrvTorqAct(0.0)
    , u8Xmc(0.0)
    , u8Ymc(0.0)
    , u8YawThetaVehicle(0.0)
    , u8PitchThetaVehicle(0.0)
    , u8RollThetaVehicle(0.0)
    , u8PitchRateVehicle(0.0)
    , u8RollRateVehicle(0.0)
    , u8SinSlopeout(0.0)
    , u8VehicleCurv(0.0)
    , u8TmotorCmd(0.0)
    , u8Tmotor(0.0)
    , u8EnergySourceLevel(0.0)
    , u8WLFWheelSpd(0.0)
    , u8WRFWheelSpd(0.0)
    , u8WLRWheelSpd(0.0)
    , u8WRRWheelSpd(0.0)
    , u8WGearSpd(0.0)
    , u1LFWheelRotatedDir(0)
    , u1LRWheelRotatedDir(0)
    , u1RFWheelRotatedDir(0)
    , u1RRWheelRotatedDir(0)
    , u1BrakePedalStatus(0)
    , u1VehicleDir(0)
    , u1BrkType(0)
    , u1Gear(0)  {
  (void)_alloc;
    }



   typedef uint32_t _u4ObjectId_type;
  _u4ObjectId_type u4ObjectId;

   typedef float _u4MtWheel_type;
  _u4MtWheel_type u4MtWheel;

   typedef double _u8MasterCylinderPressure_type;
  _u8MasterCylinderPressure_type u8MasterCylinderPressure;

   typedef double _u8SteeringWheel_type;
  _u8SteeringWheel_type u8SteeringWheel;

   typedef double _u8ThrottlePedal_type;
  _u8ThrottlePedal_type u8ThrottlePedal;

   typedef double _u8BrakePedal_type;
  _u8BrakePedal_type u8BrakePedal;

   typedef double _u8AccelTgt_type;
  _u8AccelTgt_type u8AccelTgt;

   typedef double _u8SteeringTorque_type;
  _u8SteeringTorque_type u8SteeringTorque;

   typedef double _u8StopDistance_type;
  _u8StopDistance_type u8StopDistance;

   typedef double _u8TargetSpeed_type;
  _u8TargetSpeed_type u8TargetSpeed;

   typedef double _u8Vx_type;
  _u8Vx_type u8Vx;

   typedef double _u8Wr_type;
  _u8Wr_type u8Wr;

   typedef double _u8VLFWheelSpd_type;
  _u8VLFWheelSpd_type u8VLFWheelSpd;

   typedef double _u8VRFWheelSpd_type;
  _u8VRFWheelSpd_type u8VRFWheelSpd;

   typedef double _u8VLRWheelSpd_type;
  _u8VLRWheelSpd_type u8VLRWheelSpd;

   typedef double _u8VRRWheelSpd_type;
  _u8VRRWheelSpd_type u8VRRWheelSpd;

   typedef double _u8Ax_type;
  _u8Ax_type u8Ax;

   typedef double _u8Ay_type;
  _u8Ay_type u8Ay;

   typedef double _u8SteeringWheelAngularRate_type;
  _u8SteeringWheelAngularRate_type u8SteeringWheelAngularRate;

   typedef double _u8DrvTorqAct_type;
  _u8DrvTorqAct_type u8DrvTorqAct;

   typedef double _u8Xmc_type;
  _u8Xmc_type u8Xmc;

   typedef double _u8Ymc_type;
  _u8Ymc_type u8Ymc;

   typedef double _u8YawThetaVehicle_type;
  _u8YawThetaVehicle_type u8YawThetaVehicle;

   typedef double _u8PitchThetaVehicle_type;
  _u8PitchThetaVehicle_type u8PitchThetaVehicle;

   typedef double _u8RollThetaVehicle_type;
  _u8RollThetaVehicle_type u8RollThetaVehicle;

   typedef double _u8PitchRateVehicle_type;
  _u8PitchRateVehicle_type u8PitchRateVehicle;

   typedef double _u8RollRateVehicle_type;
  _u8RollRateVehicle_type u8RollRateVehicle;

   typedef double _u8SinSlopeout_type;
  _u8SinSlopeout_type u8SinSlopeout;

   typedef double _u8VehicleCurv_type;
  _u8VehicleCurv_type u8VehicleCurv;

   typedef double _u8TmotorCmd_type;
  _u8TmotorCmd_type u8TmotorCmd;

   typedef double _u8Tmotor_type;
  _u8Tmotor_type u8Tmotor;

   typedef double _u8EnergySourceLevel_type;
  _u8EnergySourceLevel_type u8EnergySourceLevel;

   typedef double _u8WLFWheelSpd_type;
  _u8WLFWheelSpd_type u8WLFWheelSpd;

   typedef double _u8WRFWheelSpd_type;
  _u8WRFWheelSpd_type u8WRFWheelSpd;

   typedef double _u8WLRWheelSpd_type;
  _u8WLRWheelSpd_type u8WLRWheelSpd;

   typedef double _u8WRRWheelSpd_type;
  _u8WRRWheelSpd_type u8WRRWheelSpd;

   typedef double _u8WGearSpd_type;
  _u8WGearSpd_type u8WGearSpd;

   typedef uint8_t _u1LFWheelRotatedDir_type;
  _u1LFWheelRotatedDir_type u1LFWheelRotatedDir;

   typedef uint8_t _u1LRWheelRotatedDir_type;
  _u1LRWheelRotatedDir_type u1LRWheelRotatedDir;

   typedef uint8_t _u1RFWheelRotatedDir_type;
  _u1RFWheelRotatedDir_type u1RFWheelRotatedDir;

   typedef uint8_t _u1RRWheelRotatedDir_type;
  _u1RRWheelRotatedDir_type u1RRWheelRotatedDir;

   typedef uint8_t _u1BrakePedalStatus_type;
  _u1BrakePedalStatus_type u1BrakePedalStatus;

   typedef uint8_t _u1VehicleDir_type;
  _u1VehicleDir_type u1VehicleDir;

   typedef uint8_t _u1BrkType_type;
  _u1BrkType_type u1BrkType;

   typedef int8_t _u1Gear_type;
  _u1Gear_type u1Gear;





  typedef boost::shared_ptr< ::RosAdapter::driver_ctrl_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::driver_ctrl_<ContainerAllocator> const> ConstPtr;

}; // struct driver_ctrl_

typedef ::RosAdapter::driver_ctrl_<std::allocator<void> > driver_ctrl;

typedef boost::shared_ptr< ::RosAdapter::driver_ctrl > driver_ctrlPtr;
typedef boost::shared_ptr< ::RosAdapter::driver_ctrl const> driver_ctrlConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::driver_ctrl_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::driver_ctrl_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::driver_ctrl_<ContainerAllocator1> & lhs, const ::RosAdapter::driver_ctrl_<ContainerAllocator2> & rhs)
{
  return lhs.u4ObjectId == rhs.u4ObjectId &&
    lhs.u4MtWheel == rhs.u4MtWheel &&
    lhs.u8MasterCylinderPressure == rhs.u8MasterCylinderPressure &&
    lhs.u8SteeringWheel == rhs.u8SteeringWheel &&
    lhs.u8ThrottlePedal == rhs.u8ThrottlePedal &&
    lhs.u8BrakePedal == rhs.u8BrakePedal &&
    lhs.u8AccelTgt == rhs.u8AccelTgt &&
    lhs.u8SteeringTorque == rhs.u8SteeringTorque &&
    lhs.u8StopDistance == rhs.u8StopDistance &&
    lhs.u8TargetSpeed == rhs.u8TargetSpeed &&
    lhs.u8Vx == rhs.u8Vx &&
    lhs.u8Wr == rhs.u8Wr &&
    lhs.u8VLFWheelSpd == rhs.u8VLFWheelSpd &&
    lhs.u8VRFWheelSpd == rhs.u8VRFWheelSpd &&
    lhs.u8VLRWheelSpd == rhs.u8VLRWheelSpd &&
    lhs.u8VRRWheelSpd == rhs.u8VRRWheelSpd &&
    lhs.u8Ax == rhs.u8Ax &&
    lhs.u8Ay == rhs.u8Ay &&
    lhs.u8SteeringWheelAngularRate == rhs.u8SteeringWheelAngularRate &&
    lhs.u8DrvTorqAct == rhs.u8DrvTorqAct &&
    lhs.u8Xmc == rhs.u8Xmc &&
    lhs.u8Ymc == rhs.u8Ymc &&
    lhs.u8YawThetaVehicle == rhs.u8YawThetaVehicle &&
    lhs.u8PitchThetaVehicle == rhs.u8PitchThetaVehicle &&
    lhs.u8RollThetaVehicle == rhs.u8RollThetaVehicle &&
    lhs.u8PitchRateVehicle == rhs.u8PitchRateVehicle &&
    lhs.u8RollRateVehicle == rhs.u8RollRateVehicle &&
    lhs.u8SinSlopeout == rhs.u8SinSlopeout &&
    lhs.u8VehicleCurv == rhs.u8VehicleCurv &&
    lhs.u8TmotorCmd == rhs.u8TmotorCmd &&
    lhs.u8Tmotor == rhs.u8Tmotor &&
    lhs.u8EnergySourceLevel == rhs.u8EnergySourceLevel &&
    lhs.u8WLFWheelSpd == rhs.u8WLFWheelSpd &&
    lhs.u8WRFWheelSpd == rhs.u8WRFWheelSpd &&
    lhs.u8WLRWheelSpd == rhs.u8WLRWheelSpd &&
    lhs.u8WRRWheelSpd == rhs.u8WRRWheelSpd &&
    lhs.u8WGearSpd == rhs.u8WGearSpd &&
    lhs.u1LFWheelRotatedDir == rhs.u1LFWheelRotatedDir &&
    lhs.u1LRWheelRotatedDir == rhs.u1LRWheelRotatedDir &&
    lhs.u1RFWheelRotatedDir == rhs.u1RFWheelRotatedDir &&
    lhs.u1RRWheelRotatedDir == rhs.u1RRWheelRotatedDir &&
    lhs.u1BrakePedalStatus == rhs.u1BrakePedalStatus &&
    lhs.u1VehicleDir == rhs.u1VehicleDir &&
    lhs.u1BrkType == rhs.u1BrkType &&
    lhs.u1Gear == rhs.u1Gear;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::driver_ctrl_<ContainerAllocator1> & lhs, const ::RosAdapter::driver_ctrl_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::driver_ctrl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::driver_ctrl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::driver_ctrl_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "cc27883f2d6c80938a7ec2f45203e918";
  }

  static const char* value(const ::RosAdapter::driver_ctrl_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xcc27883f2d6c8093ULL;
  static const uint64_t static_value2 = 0x8a7ec2f45203e918ULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/driver_ctrl";
  }

  static const char* value(const ::RosAdapter::driver_ctrl_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# /** ------ 驾驶员控制输入的信息 ------ */\n"
"\n"
"uint32       u4ObjectId\n"
"float32      u4MtWheel\n"
"float64      u8MasterCylinderPressure\n"
"float64      u8SteeringWheel\n"
"float64      u8ThrottlePedal\n"
"float64      u8BrakePedal\n"
"float64      u8AccelTgt\n"
"float64      u8SteeringTorque\n"
"float64      u8StopDistance\n"
"float64      u8TargetSpeed\n"
"float64      u8Vx\n"
"float64      u8Wr\n"
"float64      u8VLFWheelSpd\n"
"float64      u8VRFWheelSpd\n"
"float64      u8VLRWheelSpd\n"
"float64      u8VRRWheelSpd\n"
"float64      u8Ax\n"
"float64      u8Ay\n"
"float64      u8SteeringWheelAngularRate\n"
"float64      u8DrvTorqAct\n"
"float64      u8Xmc\n"
"float64      u8Ymc\n"
"float64      u8YawThetaVehicle\n"
"float64      u8PitchThetaVehicle\n"
"float64      u8RollThetaVehicle\n"
"float64      u8PitchRateVehicle\n"
"float64      u8RollRateVehicle\n"
"float64      u8SinSlopeout\n"
"float64      u8VehicleCurv\n"
"float64      u8TmotorCmd\n"
"float64      u8Tmotor\n"
"float64      u8EnergySourceLevel\n"
"float64      u8WLFWheelSpd\n"
"float64      u8WRFWheelSpd\n"
"float64      u8WLRWheelSpd\n"
"float64      u8WRRWheelSpd\n"
"float64      u8WGearSpd\n"
"uint8        u1LFWheelRotatedDir\n"
"uint8        u1LRWheelRotatedDir\n"
"uint8        u1RFWheelRotatedDir\n"
"uint8        u1RRWheelRotatedDir\n"
"uint8        u1BrakePedalStatus\n"
"uint8        u1VehicleDir\n"
"uint8        u1BrkType\n"
"int8         u1Gear \n"
;
  }

  static const char* value(const ::RosAdapter::driver_ctrl_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.u4ObjectId);
      stream.next(m.u4MtWheel);
      stream.next(m.u8MasterCylinderPressure);
      stream.next(m.u8SteeringWheel);
      stream.next(m.u8ThrottlePedal);
      stream.next(m.u8BrakePedal);
      stream.next(m.u8AccelTgt);
      stream.next(m.u8SteeringTorque);
      stream.next(m.u8StopDistance);
      stream.next(m.u8TargetSpeed);
      stream.next(m.u8Vx);
      stream.next(m.u8Wr);
      stream.next(m.u8VLFWheelSpd);
      stream.next(m.u8VRFWheelSpd);
      stream.next(m.u8VLRWheelSpd);
      stream.next(m.u8VRRWheelSpd);
      stream.next(m.u8Ax);
      stream.next(m.u8Ay);
      stream.next(m.u8SteeringWheelAngularRate);
      stream.next(m.u8DrvTorqAct);
      stream.next(m.u8Xmc);
      stream.next(m.u8Ymc);
      stream.next(m.u8YawThetaVehicle);
      stream.next(m.u8PitchThetaVehicle);
      stream.next(m.u8RollThetaVehicle);
      stream.next(m.u8PitchRateVehicle);
      stream.next(m.u8RollRateVehicle);
      stream.next(m.u8SinSlopeout);
      stream.next(m.u8VehicleCurv);
      stream.next(m.u8TmotorCmd);
      stream.next(m.u8Tmotor);
      stream.next(m.u8EnergySourceLevel);
      stream.next(m.u8WLFWheelSpd);
      stream.next(m.u8WRFWheelSpd);
      stream.next(m.u8WLRWheelSpd);
      stream.next(m.u8WRRWheelSpd);
      stream.next(m.u8WGearSpd);
      stream.next(m.u1LFWheelRotatedDir);
      stream.next(m.u1LRWheelRotatedDir);
      stream.next(m.u1RFWheelRotatedDir);
      stream.next(m.u1RRWheelRotatedDir);
      stream.next(m.u1BrakePedalStatus);
      stream.next(m.u1VehicleDir);
      stream.next(m.u1BrkType);
      stream.next(m.u1Gear);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct driver_ctrl_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::driver_ctrl_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::driver_ctrl_<ContainerAllocator>& v)
  {
    s << indent << "u4ObjectId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.u4ObjectId);
    s << indent << "u4MtWheel: ";
    Printer<float>::stream(s, indent + "  ", v.u4MtWheel);
    s << indent << "u8MasterCylinderPressure: ";
    Printer<double>::stream(s, indent + "  ", v.u8MasterCylinderPressure);
    s << indent << "u8SteeringWheel: ";
    Printer<double>::stream(s, indent + "  ", v.u8SteeringWheel);
    s << indent << "u8ThrottlePedal: ";
    Printer<double>::stream(s, indent + "  ", v.u8ThrottlePedal);
    s << indent << "u8BrakePedal: ";
    Printer<double>::stream(s, indent + "  ", v.u8BrakePedal);
    s << indent << "u8AccelTgt: ";
    Printer<double>::stream(s, indent + "  ", v.u8AccelTgt);
    s << indent << "u8SteeringTorque: ";
    Printer<double>::stream(s, indent + "  ", v.u8SteeringTorque);
    s << indent << "u8StopDistance: ";
    Printer<double>::stream(s, indent + "  ", v.u8StopDistance);
    s << indent << "u8TargetSpeed: ";
    Printer<double>::stream(s, indent + "  ", v.u8TargetSpeed);
    s << indent << "u8Vx: ";
    Printer<double>::stream(s, indent + "  ", v.u8Vx);
    s << indent << "u8Wr: ";
    Printer<double>::stream(s, indent + "  ", v.u8Wr);
    s << indent << "u8VLFWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8VLFWheelSpd);
    s << indent << "u8VRFWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8VRFWheelSpd);
    s << indent << "u8VLRWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8VLRWheelSpd);
    s << indent << "u8VRRWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8VRRWheelSpd);
    s << indent << "u8Ax: ";
    Printer<double>::stream(s, indent + "  ", v.u8Ax);
    s << indent << "u8Ay: ";
    Printer<double>::stream(s, indent + "  ", v.u8Ay);
    s << indent << "u8SteeringWheelAngularRate: ";
    Printer<double>::stream(s, indent + "  ", v.u8SteeringWheelAngularRate);
    s << indent << "u8DrvTorqAct: ";
    Printer<double>::stream(s, indent + "  ", v.u8DrvTorqAct);
    s << indent << "u8Xmc: ";
    Printer<double>::stream(s, indent + "  ", v.u8Xmc);
    s << indent << "u8Ymc: ";
    Printer<double>::stream(s, indent + "  ", v.u8Ymc);
    s << indent << "u8YawThetaVehicle: ";
    Printer<double>::stream(s, indent + "  ", v.u8YawThetaVehicle);
    s << indent << "u8PitchThetaVehicle: ";
    Printer<double>::stream(s, indent + "  ", v.u8PitchThetaVehicle);
    s << indent << "u8RollThetaVehicle: ";
    Printer<double>::stream(s, indent + "  ", v.u8RollThetaVehicle);
    s << indent << "u8PitchRateVehicle: ";
    Printer<double>::stream(s, indent + "  ", v.u8PitchRateVehicle);
    s << indent << "u8RollRateVehicle: ";
    Printer<double>::stream(s, indent + "  ", v.u8RollRateVehicle);
    s << indent << "u8SinSlopeout: ";
    Printer<double>::stream(s, indent + "  ", v.u8SinSlopeout);
    s << indent << "u8VehicleCurv: ";
    Printer<double>::stream(s, indent + "  ", v.u8VehicleCurv);
    s << indent << "u8TmotorCmd: ";
    Printer<double>::stream(s, indent + "  ", v.u8TmotorCmd);
    s << indent << "u8Tmotor: ";
    Printer<double>::stream(s, indent + "  ", v.u8Tmotor);
    s << indent << "u8EnergySourceLevel: ";
    Printer<double>::stream(s, indent + "  ", v.u8EnergySourceLevel);
    s << indent << "u8WLFWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8WLFWheelSpd);
    s << indent << "u8WRFWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8WRFWheelSpd);
    s << indent << "u8WLRWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8WLRWheelSpd);
    s << indent << "u8WRRWheelSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8WRRWheelSpd);
    s << indent << "u8WGearSpd: ";
    Printer<double>::stream(s, indent + "  ", v.u8WGearSpd);
    s << indent << "u1LFWheelRotatedDir: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1LFWheelRotatedDir);
    s << indent << "u1LRWheelRotatedDir: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1LRWheelRotatedDir);
    s << indent << "u1RFWheelRotatedDir: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1RFWheelRotatedDir);
    s << indent << "u1RRWheelRotatedDir: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1RRWheelRotatedDir);
    s << indent << "u1BrakePedalStatus: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1BrakePedalStatus);
    s << indent << "u1VehicleDir: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1VehicleDir);
    s << indent << "u1BrkType: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1BrkType);
    s << indent << "u1Gear: ";
    Printer<int8_t>::stream(s, indent + "  ", v.u1Gear);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_DRIVER_CTRL_H
