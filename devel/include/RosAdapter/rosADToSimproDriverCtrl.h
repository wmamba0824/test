// Generated by gencpp from file RosAdapter/rosADToSimproDriverCtrl.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_ROSADTOSIMPRODRIVERCTRL_H
#define ROSADAPTER_MESSAGE_ROSADTOSIMPRODRIVERCTRL_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <RosAdapter/header.h>
#include <RosAdapter/driver_ctrl.h>
#include <RosAdapter/mil_ego_state.h>
#include <RosAdapter/csv_data.h>
#include <RosAdapter/v2x_warninginformation.h>
#include <RosAdapter/obu_vnfp_info.h>
#include <RosAdapter/ad_signal_data.h>
#include <RosAdapter/ttc_control.h>

namespace RosAdapter
{
template <class ContainerAllocator>
struct rosADToSimproDriverCtrl_
{
  typedef rosADToSimproDriverCtrl_<ContainerAllocator> Type;

  rosADToSimproDriverCtrl_()
    : head()
    , driverCtrl()
    , egoState()
    , csvData()
    , v2xWarning()
    , obuVnfpInfo()
    , adSignalDatas()
    , ttcControl()  {
    }
  rosADToSimproDriverCtrl_(const ContainerAllocator& _alloc)
    : head(_alloc)
    , driverCtrl(_alloc)
    , egoState(_alloc)
    , csvData(_alloc)
    , v2xWarning(_alloc)
    , obuVnfpInfo(_alloc)
    , adSignalDatas(_alloc)
    , ttcControl(_alloc)  {
  (void)_alloc;
    }



   typedef  ::RosAdapter::header_<ContainerAllocator>  _head_type;
  _head_type head;

   typedef  ::RosAdapter::driver_ctrl_<ContainerAllocator>  _driverCtrl_type;
  _driverCtrl_type driverCtrl;

   typedef  ::RosAdapter::mil_ego_state_<ContainerAllocator>  _egoState_type;
  _egoState_type egoState;

   typedef  ::RosAdapter::csv_data_<ContainerAllocator>  _csvData_type;
  _csvData_type csvData;

   typedef  ::RosAdapter::v2x_warninginformation_<ContainerAllocator>  _v2xWarning_type;
  _v2xWarning_type v2xWarning;

   typedef  ::RosAdapter::obu_vnfp_info_<ContainerAllocator>  _obuVnfpInfo_type;
  _obuVnfpInfo_type obuVnfpInfo;

   typedef  ::RosAdapter::ad_signal_data_<ContainerAllocator>  _adSignalDatas_type;
  _adSignalDatas_type adSignalDatas;

   typedef  ::RosAdapter::ttc_control_<ContainerAllocator>  _ttcControl_type;
  _ttcControl_type ttcControl;





  typedef boost::shared_ptr< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> const> ConstPtr;

}; // struct rosADToSimproDriverCtrl_

typedef ::RosAdapter::rosADToSimproDriverCtrl_<std::allocator<void> > rosADToSimproDriverCtrl;

typedef boost::shared_ptr< ::RosAdapter::rosADToSimproDriverCtrl > rosADToSimproDriverCtrlPtr;
typedef boost::shared_ptr< ::RosAdapter::rosADToSimproDriverCtrl const> rosADToSimproDriverCtrlConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator1> & lhs, const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator2> & rhs)
{
  return lhs.head == rhs.head &&
    lhs.driverCtrl == rhs.driverCtrl &&
    lhs.egoState == rhs.egoState &&
    lhs.csvData == rhs.csvData &&
    lhs.v2xWarning == rhs.v2xWarning &&
    lhs.obuVnfpInfo == rhs.obuVnfpInfo &&
    lhs.adSignalDatas == rhs.adSignalDatas &&
    lhs.ttcControl == rhs.ttcControl;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator1> & lhs, const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7665be9ba648b35520d49a30fcb2afed";
  }

  static const char* value(const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7665be9ba648b355ULL;
  static const uint64_t static_value2 = 0x20d49a30fcb2afedULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/rosADToSimproDriverCtrl";
  }

  static const char* value(const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
{
  static const char* value()
  {
    return "header                            head\n"
"driver_ctrl                       driverCtrl\n"
"mil_ego_state                     egoState\n"
"csv_data                          csvData\n"
"v2x_warninginformation            v2xWarning\n"
"obu_vnfp_info                     obuVnfpInfo\n"
"ad_signal_data                    adSignalDatas\n"
"ttc_control                       ttcControl\n"
"================================================================================\n"
"MSG: RosAdapter/header\n"
"# /** ------ Msg header ------ */\n"
"float64 u8SimTime\n"
"uint32  u4HeaderSize\n"
"uint32  u4DataSize\n"
"uint32  u4FrameNo\n"
"================================================================================\n"
"MSG: RosAdapter/driver_ctrl\n"
"# /** ------ 驾驶员控制输入的信息 ------ */\n"
"\n"
"uint32       u4ObjectId\n"
"float32      u4MtWheel\n"
"float64      u8MasterCylinderPressure\n"
"float64      u8SteeringWheel\n"
"float64      u8ThrottlePedal\n"
"float64      u8BrakePedal\n"
"float64      u8AccelTgt\n"
"float64      u8SteeringTorque\n"
"float64      u8StopDistance\n"
"float64      u8TargetSpeed\n"
"float64      u8Vx\n"
"float64      u8Wr\n"
"float64      u8VLFWheelSpd\n"
"float64      u8VRFWheelSpd\n"
"float64      u8VLRWheelSpd\n"
"float64      u8VRRWheelSpd\n"
"float64      u8Ax\n"
"float64      u8Ay\n"
"float64      u8SteeringWheelAngularRate\n"
"float64      u8DrvTorqAct\n"
"float64      u8Xmc\n"
"float64      u8Ymc\n"
"float64      u8YawThetaVehicle\n"
"float64      u8PitchThetaVehicle\n"
"float64      u8RollThetaVehicle\n"
"float64      u8PitchRateVehicle\n"
"float64      u8RollRateVehicle\n"
"float64      u8SinSlopeout\n"
"float64      u8VehicleCurv\n"
"float64      u8TmotorCmd\n"
"float64      u8Tmotor\n"
"float64      u8EnergySourceLevel\n"
"float64      u8WLFWheelSpd\n"
"float64      u8WRFWheelSpd\n"
"float64      u8WLRWheelSpd\n"
"float64      u8WRRWheelSpd\n"
"float64      u8WGearSpd\n"
"uint8        u1LFWheelRotatedDir\n"
"uint8        u1LRWheelRotatedDir\n"
"uint8        u1RFWheelRotatedDir\n"
"uint8        u1RRWheelRotatedDir\n"
"uint8        u1BrakePedalStatus\n"
"uint8        u1VehicleDir\n"
"uint8        u1BrkType\n"
"int8         u1Gear \n"
"================================================================================\n"
"MSG: RosAdapter/mil_ego_state\n"
"# /** ------ MIL测试主车信息描述包 ------ */\n"
"\n"
"object_state   sObjectState\n"
"float64        u4initSpeed\n"
"float64        u8DistRoadEnd\n"
"uint32         u4LightMask               \n"
"float32        u4WheelSpeedFL\n"
"float32        u4WheelSpeedFR\n"
"float32        u4WheelSpeedRL\n"
"float32        u4WheelSpeedRR\n"
"float32        u4MasterCylinderPressure\n"
"float32        u4WheelHeightLF\n"
"float32        u4WheelHeightLR\n"
"float32        u4WheelHeightRF\n"
"float32        u4WheelHeightRR\n"
"float32        u4SteerAngle\n"
"uint8          u1objQuantity\n"
"uint8          u1irc_id\n"
"uint8          u1irc_left_id\n"
"uint8          u1irc_right_id\n"
"uint8          u1cipv_id\n"
"uint8          u1lmc_id\n"
"uint8          u1rmc_id\n"
"uint8          u1isReachInitSpeed\n"
"================================================================================\n"
"MSG: RosAdapter/object_state\n"
"# /** ------ 对象信息 ------ */\n"
"coord           sSpeed\n"
"coord           sAccel\n"
"geometry        sGeo\n"
"coord           sPos\n"
"string          au1Name\n"
"string          au1ModelFileName\n"
"string          au1ModelName\n"
"float64[]       au8ParamScale\n"
"uint64          u8RoadId\n"
"float64         u8SpeedLimit\n"
"uint32          u4Id\n"
"float32         u4RoadS\n"
"float32         u4RoadT\n"
"float32         u4HdgRel\n"
"float32         u4LaneOffset\n"
"float32         u4TraveledDist\n"
"uint16          u2visMask\n"
"uint8           u1Type\n"
"int8            u1LaneId\n"
"uint8           u1Dir\n"
"bool            u1IsOnRoad\n"
"uint8           u1category\n"
"================================================================================\n"
"MSG: RosAdapter/coord\n"
"# /** ------ 坐标 ------ */\n"
"float64   u8X\n"
"float64   u8Y\n"
"float64   u8Z\n"
"float32   u4H\n"
"float32   u4P\n"
"float32   u4R\n"
"uint8     u1Type\n"
"================================================================================\n"
"MSG: RosAdapter/geometry\n"
"# /** ------ 几何信息 ------ */\n"
"float32 u4DimX\n"
"float32 u4DimY\n"
"float32 u4DimZ\n"
"float32 u4OffX\n"
"float32 u4OffY\n"
"float32 u4OffZ\n"
"================================================================================\n"
"MSG: RosAdapter/csv_data\n"
"# /** ------ AD发送给simpro的CSV数据 ------ */\n"
"\n"
"float32  u4AccelTgt\n"
"float32  u4SteeringWheel\n"
"uint32   u4ADStatus\n"
"================================================================================\n"
"MSG: RosAdapter/v2x_warninginformation\n"
"# /** ------ V2X 告警信息 ------ */\n"
"\n"
"uint32 u4Type\n"
"================================================================================\n"
"MSG: RosAdapter/obu_vnfp_info\n"
"uint32   type\n"
"================================================================================\n"
"MSG: RosAdapter/ad_signal_data\n"
"string      au1SignalName\n"
"float64     u8SignalValue\n"
"================================================================================\n"
"MSG: RosAdapter/ttc_control\n"
"uint32  u4Status\n"
;
  }

  static const char* value(const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.head);
      stream.next(m.driverCtrl);
      stream.next(m.egoState);
      stream.next(m.csvData);
      stream.next(m.v2xWarning);
      stream.next(m.obuVnfpInfo);
      stream.next(m.adSignalDatas);
      stream.next(m.ttcControl);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct rosADToSimproDriverCtrl_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::rosADToSimproDriverCtrl_<ContainerAllocator>& v)
  {
    s << indent << "head: ";
    s << std::endl;
    Printer< ::RosAdapter::header_<ContainerAllocator> >::stream(s, indent + "  ", v.head);
    s << indent << "driverCtrl: ";
    s << std::endl;
    Printer< ::RosAdapter::driver_ctrl_<ContainerAllocator> >::stream(s, indent + "  ", v.driverCtrl);
    s << indent << "egoState: ";
    s << std::endl;
    Printer< ::RosAdapter::mil_ego_state_<ContainerAllocator> >::stream(s, indent + "  ", v.egoState);
    s << indent << "csvData: ";
    s << std::endl;
    Printer< ::RosAdapter::csv_data_<ContainerAllocator> >::stream(s, indent + "  ", v.csvData);
    s << indent << "v2xWarning: ";
    s << std::endl;
    Printer< ::RosAdapter::v2x_warninginformation_<ContainerAllocator> >::stream(s, indent + "  ", v.v2xWarning);
    s << indent << "obuVnfpInfo: ";
    s << std::endl;
    Printer< ::RosAdapter::obu_vnfp_info_<ContainerAllocator> >::stream(s, indent + "  ", v.obuVnfpInfo);
    s << indent << "adSignalDatas: ";
    s << std::endl;
    Printer< ::RosAdapter::ad_signal_data_<ContainerAllocator> >::stream(s, indent + "  ", v.adSignalDatas);
    s << indent << "ttcControl: ";
    s << std::endl;
    Printer< ::RosAdapter::ttc_control_<ContainerAllocator> >::stream(s, indent + "  ", v.ttcControl);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_ROSADTOSIMPRODRIVERCTRL_H
