// Generated by gencpp from file RosAdapter/mil_roadmark.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_MIL_ROADMARK_H
#define ROSADAPTER_MESSAGE_MIL_ROADMARK_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace RosAdapter
{
template <class ContainerAllocator>
struct mil_roadmark_
{
  typedef mil_roadmark_<ContainerAllocator> Type;

  mil_roadmark_()
    : u8RoadId(0)
    , curvVert(0.0)
    , u4StartDx(0.0)
    , u4Width(0.0)
    , u4ViewRangeStart(0.0)
    , u4ViewRangeEnd(0.0)
    , u4MeasuredVREnd(0.0)
    , u4C0(0.0)
    , u4C1(0.0)
    , u4C2(0.0)
    , u4C3(0.0)
    , u2LaneChange(0)
    , u1LaneId(0)
    , u1Quality(0)
    , u1Type(0)
    , u1Color(0)
    , u1LeftCrossing(0)
    , u1RightCrossing(0)  {
    }
  mil_roadmark_(const ContainerAllocator& _alloc)
    : u8RoadId(0)
    , curvVert(0.0)
    , u4StartDx(0.0)
    , u4Width(0.0)
    , u4ViewRangeStart(0.0)
    , u4ViewRangeEnd(0.0)
    , u4MeasuredVREnd(0.0)
    , u4C0(0.0)
    , u4C1(0.0)
    , u4C2(0.0)
    , u4C3(0.0)
    , u2LaneChange(0)
    , u1LaneId(0)
    , u1Quality(0)
    , u1Type(0)
    , u1Color(0)
    , u1LeftCrossing(0)
    , u1RightCrossing(0)  {
  (void)_alloc;
    }



   typedef uint64_t _u8RoadId_type;
  _u8RoadId_type u8RoadId;

   typedef double _curvVert_type;
  _curvVert_type curvVert;

   typedef float _u4StartDx_type;
  _u4StartDx_type u4StartDx;

   typedef float _u4Width_type;
  _u4Width_type u4Width;

   typedef float _u4ViewRangeStart_type;
  _u4ViewRangeStart_type u4ViewRangeStart;

   typedef float _u4ViewRangeEnd_type;
  _u4ViewRangeEnd_type u4ViewRangeEnd;

   typedef float _u4MeasuredVREnd_type;
  _u4MeasuredVREnd_type u4MeasuredVREnd;

   typedef float _u4C0_type;
  _u4C0_type u4C0;

   typedef float _u4C1_type;
  _u4C1_type u4C1;

   typedef float _u4C2_type;
  _u4C2_type u4C2;

   typedef float _u4C3_type;
  _u4C3_type u4C3;

   typedef uint16_t _u2LaneChange_type;
  _u2LaneChange_type u2LaneChange;

   typedef int8_t _u1LaneId_type;
  _u1LaneId_type u1LaneId;

   typedef uint8_t _u1Quality_type;
  _u1Quality_type u1Quality;

   typedef uint8_t _u1Type_type;
  _u1Type_type u1Type;

   typedef uint8_t _u1Color_type;
  _u1Color_type u1Color;

   typedef uint8_t _u1LeftCrossing_type;
  _u1LeftCrossing_type u1LeftCrossing;

   typedef uint8_t _u1RightCrossing_type;
  _u1RightCrossing_type u1RightCrossing;





  typedef boost::shared_ptr< ::RosAdapter::mil_roadmark_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::mil_roadmark_<ContainerAllocator> const> ConstPtr;

}; // struct mil_roadmark_

typedef ::RosAdapter::mil_roadmark_<std::allocator<void> > mil_roadmark;

typedef boost::shared_ptr< ::RosAdapter::mil_roadmark > mil_roadmarkPtr;
typedef boost::shared_ptr< ::RosAdapter::mil_roadmark const> mil_roadmarkConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::mil_roadmark_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::mil_roadmark_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::mil_roadmark_<ContainerAllocator1> & lhs, const ::RosAdapter::mil_roadmark_<ContainerAllocator2> & rhs)
{
  return lhs.u8RoadId == rhs.u8RoadId &&
    lhs.curvVert == rhs.curvVert &&
    lhs.u4StartDx == rhs.u4StartDx &&
    lhs.u4Width == rhs.u4Width &&
    lhs.u4ViewRangeStart == rhs.u4ViewRangeStart &&
    lhs.u4ViewRangeEnd == rhs.u4ViewRangeEnd &&
    lhs.u4MeasuredVREnd == rhs.u4MeasuredVREnd &&
    lhs.u4C0 == rhs.u4C0 &&
    lhs.u4C1 == rhs.u4C1 &&
    lhs.u4C2 == rhs.u4C2 &&
    lhs.u4C3 == rhs.u4C3 &&
    lhs.u2LaneChange == rhs.u2LaneChange &&
    lhs.u1LaneId == rhs.u1LaneId &&
    lhs.u1Quality == rhs.u1Quality &&
    lhs.u1Type == rhs.u1Type &&
    lhs.u1Color == rhs.u1Color &&
    lhs.u1LeftCrossing == rhs.u1LeftCrossing &&
    lhs.u1RightCrossing == rhs.u1RightCrossing;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::mil_roadmark_<ContainerAllocator1> & lhs, const ::RosAdapter::mil_roadmark_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::mil_roadmark_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::mil_roadmark_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::mil_roadmark_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7aee4a86eef20d62dcd9e9c417a01ceb";
  }

  static const char* value(const ::RosAdapter::mil_roadmark_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7aee4a86eef20d62ULL;
  static const uint64_t static_value2 = 0xdcd9e9c417a01cebULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/mil_roadmark";
  }

  static const char* value(const ::RosAdapter::mil_roadmark_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
{
  static const char* value()
  {
    return " # /** ------ MIL测试车道线信息描述包 ------ */\n"
"\n"
"uint64  u8RoadId\n"
"float64 curvVert\n"
"float32 u4StartDx\n"
"float32 u4Width\n"
"float32 u4ViewRangeStart\n"
"float32 u4ViewRangeEnd\n"
"float32 u4MeasuredVREnd\n"
"float32 u4C0\n"
"float32 u4C1\n"
"float32 u4C2\n"
"float32 u4C3\n"
"uint16  u2LaneChange\n"
"int8    u1LaneId\n"
"uint8   u1Quality\n"
"uint8   u1Type\n"
"uint8   u1Color\n"
"uint8   u1LeftCrossing\n"
"uint8   u1RightCrossing\n"
;
  }

  static const char* value(const ::RosAdapter::mil_roadmark_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.u8RoadId);
      stream.next(m.curvVert);
      stream.next(m.u4StartDx);
      stream.next(m.u4Width);
      stream.next(m.u4ViewRangeStart);
      stream.next(m.u4ViewRangeEnd);
      stream.next(m.u4MeasuredVREnd);
      stream.next(m.u4C0);
      stream.next(m.u4C1);
      stream.next(m.u4C2);
      stream.next(m.u4C3);
      stream.next(m.u2LaneChange);
      stream.next(m.u1LaneId);
      stream.next(m.u1Quality);
      stream.next(m.u1Type);
      stream.next(m.u1Color);
      stream.next(m.u1LeftCrossing);
      stream.next(m.u1RightCrossing);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mil_roadmark_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::mil_roadmark_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::mil_roadmark_<ContainerAllocator>& v)
  {
    s << indent << "u8RoadId: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.u8RoadId);
    s << indent << "curvVert: ";
    Printer<double>::stream(s, indent + "  ", v.curvVert);
    s << indent << "u4StartDx: ";
    Printer<float>::stream(s, indent + "  ", v.u4StartDx);
    s << indent << "u4Width: ";
    Printer<float>::stream(s, indent + "  ", v.u4Width);
    s << indent << "u4ViewRangeStart: ";
    Printer<float>::stream(s, indent + "  ", v.u4ViewRangeStart);
    s << indent << "u4ViewRangeEnd: ";
    Printer<float>::stream(s, indent + "  ", v.u4ViewRangeEnd);
    s << indent << "u4MeasuredVREnd: ";
    Printer<float>::stream(s, indent + "  ", v.u4MeasuredVREnd);
    s << indent << "u4C0: ";
    Printer<float>::stream(s, indent + "  ", v.u4C0);
    s << indent << "u4C1: ";
    Printer<float>::stream(s, indent + "  ", v.u4C1);
    s << indent << "u4C2: ";
    Printer<float>::stream(s, indent + "  ", v.u4C2);
    s << indent << "u4C3: ";
    Printer<float>::stream(s, indent + "  ", v.u4C3);
    s << indent << "u2LaneChange: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.u2LaneChange);
    s << indent << "u1LaneId: ";
    Printer<int8_t>::stream(s, indent + "  ", v.u1LaneId);
    s << indent << "u1Quality: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1Quality);
    s << indent << "u1Type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1Type);
    s << indent << "u1Color: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1Color);
    s << indent << "u1LeftCrossing: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1LeftCrossing);
    s << indent << "u1RightCrossing: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1RightCrossing);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_MIL_ROADMARK_H
