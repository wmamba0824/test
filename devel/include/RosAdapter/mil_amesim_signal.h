// Generated by gencpp from file RosAdapter/mil_amesim_signal.msg
// DO NOT EDIT!


#ifndef ROSADAPTER_MESSAGE_MIL_AMESIM_SIGNAL_H
#define ROSADAPTER_MESSAGE_MIL_AMESIM_SIGNAL_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace RosAdapter
{
template <class ContainerAllocator>
struct mil_amesim_signal_
{
  typedef mil_amesim_signal_<ContainerAllocator> Type;

  mil_amesim_signal_()
    : u4LeftLen(0.0)
    , u4NextLen(0.0)
    , u4NextAgeSpeed(0.0)
    , u4NextMinSpeed(0.0)
    , u4NextMaxSpeed(0.0)
    , u4NextGradient(0.0)
    , u4NextCongest(0.0)
    , u1RoadType(0)
    , u4DisLimit(0.0)
    , u1IsFarAwayLimit(false)
    , u4LimitSpeed(0.0)
    , ulIsJunction(false)
    , u4DisJunction(0.0)
    , ulIsFarAwayJunc(false)
    , ultrafficLightStat(0)
    , u4Curvity(0.0)
    , u4RelativeVel(0.0)
    , u4RelativeDis(0.0)  {
    }
  mil_amesim_signal_(const ContainerAllocator& _alloc)
    : u4LeftLen(0.0)
    , u4NextLen(0.0)
    , u4NextAgeSpeed(0.0)
    , u4NextMinSpeed(0.0)
    , u4NextMaxSpeed(0.0)
    , u4NextGradient(0.0)
    , u4NextCongest(0.0)
    , u1RoadType(0)
    , u4DisLimit(0.0)
    , u1IsFarAwayLimit(false)
    , u4LimitSpeed(0.0)
    , ulIsJunction(false)
    , u4DisJunction(0.0)
    , ulIsFarAwayJunc(false)
    , ultrafficLightStat(0)
    , u4Curvity(0.0)
    , u4RelativeVel(0.0)
    , u4RelativeDis(0.0)  {
  (void)_alloc;
    }



   typedef float _u4LeftLen_type;
  _u4LeftLen_type u4LeftLen;

   typedef float _u4NextLen_type;
  _u4NextLen_type u4NextLen;

   typedef float _u4NextAgeSpeed_type;
  _u4NextAgeSpeed_type u4NextAgeSpeed;

   typedef float _u4NextMinSpeed_type;
  _u4NextMinSpeed_type u4NextMinSpeed;

   typedef float _u4NextMaxSpeed_type;
  _u4NextMaxSpeed_type u4NextMaxSpeed;

   typedef float _u4NextGradient_type;
  _u4NextGradient_type u4NextGradient;

   typedef float _u4NextCongest_type;
  _u4NextCongest_type u4NextCongest;

   typedef uint8_t _u1RoadType_type;
  _u1RoadType_type u1RoadType;

   typedef float _u4DisLimit_type;
  _u4DisLimit_type u4DisLimit;

   typedef uint8_t _u1IsFarAwayLimit_type;
  _u1IsFarAwayLimit_type u1IsFarAwayLimit;

   typedef float _u4LimitSpeed_type;
  _u4LimitSpeed_type u4LimitSpeed;

   typedef uint8_t _ulIsJunction_type;
  _ulIsJunction_type ulIsJunction;

   typedef float _u4DisJunction_type;
  _u4DisJunction_type u4DisJunction;

   typedef uint8_t _ulIsFarAwayJunc_type;
  _ulIsFarAwayJunc_type ulIsFarAwayJunc;

   typedef uint8_t _ultrafficLightStat_type;
  _ultrafficLightStat_type ultrafficLightStat;

   typedef float _u4Curvity_type;
  _u4Curvity_type u4Curvity;

   typedef float _u4RelativeVel_type;
  _u4RelativeVel_type u4RelativeVel;

   typedef float _u4RelativeDis_type;
  _u4RelativeDis_type u4RelativeDis;





  typedef boost::shared_ptr< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> const> ConstPtr;

}; // struct mil_amesim_signal_

typedef ::RosAdapter::mil_amesim_signal_<std::allocator<void> > mil_amesim_signal;

typedef boost::shared_ptr< ::RosAdapter::mil_amesim_signal > mil_amesim_signalPtr;
typedef boost::shared_ptr< ::RosAdapter::mil_amesim_signal const> mil_amesim_signalConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::RosAdapter::mil_amesim_signal_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::RosAdapter::mil_amesim_signal_<ContainerAllocator1> & lhs, const ::RosAdapter::mil_amesim_signal_<ContainerAllocator2> & rhs)
{
  return lhs.u4LeftLen == rhs.u4LeftLen &&
    lhs.u4NextLen == rhs.u4NextLen &&
    lhs.u4NextAgeSpeed == rhs.u4NextAgeSpeed &&
    lhs.u4NextMinSpeed == rhs.u4NextMinSpeed &&
    lhs.u4NextMaxSpeed == rhs.u4NextMaxSpeed &&
    lhs.u4NextGradient == rhs.u4NextGradient &&
    lhs.u4NextCongest == rhs.u4NextCongest &&
    lhs.u1RoadType == rhs.u1RoadType &&
    lhs.u4DisLimit == rhs.u4DisLimit &&
    lhs.u1IsFarAwayLimit == rhs.u1IsFarAwayLimit &&
    lhs.u4LimitSpeed == rhs.u4LimitSpeed &&
    lhs.ulIsJunction == rhs.ulIsJunction &&
    lhs.u4DisJunction == rhs.u4DisJunction &&
    lhs.ulIsFarAwayJunc == rhs.ulIsFarAwayJunc &&
    lhs.ultrafficLightStat == rhs.ultrafficLightStat &&
    lhs.u4Curvity == rhs.u4Curvity &&
    lhs.u4RelativeVel == rhs.u4RelativeVel &&
    lhs.u4RelativeDis == rhs.u4RelativeDis;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::RosAdapter::mil_amesim_signal_<ContainerAllocator1> & lhs, const ::RosAdapter::mil_amesim_signal_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace RosAdapter

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b272e0120e62408b4b47d6764b084b50";
  }

  static const char* value(const ::RosAdapter::mil_amesim_signal_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb272e0120e62408bULL;
  static const uint64_t static_value2 = 0x4b47d6764b084b50ULL;
};

template<class ContainerAllocator>
struct DataType< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
{
  static const char* value()
  {
    return "RosAdapter/mil_amesim_signal";
  }

  static const char* value(const ::RosAdapter::mil_amesim_signal_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# /** ------ MIL AMESim 测试信息描述包 ------ */\n"
"\n"
"float32       u4LeftLen\n"
"float32       u4NextLen\n"
"float32       u4NextAgeSpeed\n"
"float32       u4NextMinSpeed\n"
"float32       u4NextMaxSpeed\n"
"float32       u4NextGradient\n"
"float32       u4NextCongest\n"
"uint8         u1RoadType\n"
"float32       u4DisLimit\n"
"bool          u1IsFarAwayLimit\n"
"float32       u4LimitSpeed\n"
"bool          ulIsJunction\n"
"float32       u4DisJunction\n"
"bool          ulIsFarAwayJunc\n"
"uint8         ultrafficLightStat\n"
"float32       u4Curvity\n"
"float32       u4RelativeVel\n"
"float32       u4RelativeDis\n"
;
  }

  static const char* value(const ::RosAdapter::mil_amesim_signal_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.u4LeftLen);
      stream.next(m.u4NextLen);
      stream.next(m.u4NextAgeSpeed);
      stream.next(m.u4NextMinSpeed);
      stream.next(m.u4NextMaxSpeed);
      stream.next(m.u4NextGradient);
      stream.next(m.u4NextCongest);
      stream.next(m.u1RoadType);
      stream.next(m.u4DisLimit);
      stream.next(m.u1IsFarAwayLimit);
      stream.next(m.u4LimitSpeed);
      stream.next(m.ulIsJunction);
      stream.next(m.u4DisJunction);
      stream.next(m.ulIsFarAwayJunc);
      stream.next(m.ultrafficLightStat);
      stream.next(m.u4Curvity);
      stream.next(m.u4RelativeVel);
      stream.next(m.u4RelativeDis);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mil_amesim_signal_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::RosAdapter::mil_amesim_signal_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::RosAdapter::mil_amesim_signal_<ContainerAllocator>& v)
  {
    s << indent << "u4LeftLen: ";
    Printer<float>::stream(s, indent + "  ", v.u4LeftLen);
    s << indent << "u4NextLen: ";
    Printer<float>::stream(s, indent + "  ", v.u4NextLen);
    s << indent << "u4NextAgeSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.u4NextAgeSpeed);
    s << indent << "u4NextMinSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.u4NextMinSpeed);
    s << indent << "u4NextMaxSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.u4NextMaxSpeed);
    s << indent << "u4NextGradient: ";
    Printer<float>::stream(s, indent + "  ", v.u4NextGradient);
    s << indent << "u4NextCongest: ";
    Printer<float>::stream(s, indent + "  ", v.u4NextCongest);
    s << indent << "u1RoadType: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1RoadType);
    s << indent << "u4DisLimit: ";
    Printer<float>::stream(s, indent + "  ", v.u4DisLimit);
    s << indent << "u1IsFarAwayLimit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.u1IsFarAwayLimit);
    s << indent << "u4LimitSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.u4LimitSpeed);
    s << indent << "ulIsJunction: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ulIsJunction);
    s << indent << "u4DisJunction: ";
    Printer<float>::stream(s, indent + "  ", v.u4DisJunction);
    s << indent << "ulIsFarAwayJunc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ulIsFarAwayJunc);
    s << indent << "ultrafficLightStat: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ultrafficLightStat);
    s << indent << "u4Curvity: ";
    Printer<float>::stream(s, indent + "  ", v.u4Curvity);
    s << indent << "u4RelativeVel: ";
    Printer<float>::stream(s, indent + "  ", v.u4RelativeVel);
    s << indent << "u4RelativeDis: ";
    Printer<float>::stream(s, indent + "  ", v.u4RelativeDis);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROSADAPTER_MESSAGE_MIL_AMESIM_SIGNAL_H
