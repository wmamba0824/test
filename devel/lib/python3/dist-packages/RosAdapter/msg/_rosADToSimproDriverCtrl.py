# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from RosAdapter/rosADToSimproDriverCtrl.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import RosAdapter.msg

class rosADToSimproDriverCtrl(genpy.Message):
  _md5sum = "7665be9ba648b35520d49a30fcb2afed"
  _type = "RosAdapter/rosADToSimproDriverCtrl"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """header                            head
driver_ctrl                       driverCtrl
mil_ego_state                     egoState
csv_data                          csvData
v2x_warninginformation            v2xWarning
obu_vnfp_info                     obuVnfpInfo
ad_signal_data                    adSignalDatas
ttc_control                       ttcControl
================================================================================
MSG: RosAdapter/header
# /** ------ Msg header ------ */
float64 u8SimTime
uint32  u4HeaderSize
uint32  u4DataSize
uint32  u4FrameNo
================================================================================
MSG: RosAdapter/driver_ctrl
# /** ------ 驾驶员控制输入的信息 ------ */

uint32       u4ObjectId
float32      u4MtWheel
float64      u8MasterCylinderPressure
float64      u8SteeringWheel
float64      u8ThrottlePedal
float64      u8BrakePedal
float64      u8AccelTgt
float64      u8SteeringTorque
float64      u8StopDistance
float64      u8TargetSpeed
float64      u8Vx
float64      u8Wr
float64      u8VLFWheelSpd
float64      u8VRFWheelSpd
float64      u8VLRWheelSpd
float64      u8VRRWheelSpd
float64      u8Ax
float64      u8Ay
float64      u8SteeringWheelAngularRate
float64      u8DrvTorqAct
float64      u8Xmc
float64      u8Ymc
float64      u8YawThetaVehicle
float64      u8PitchThetaVehicle
float64      u8RollThetaVehicle
float64      u8PitchRateVehicle
float64      u8RollRateVehicle
float64      u8SinSlopeout
float64      u8VehicleCurv
float64      u8TmotorCmd
float64      u8Tmotor
float64      u8EnergySourceLevel
float64      u8WLFWheelSpd
float64      u8WRFWheelSpd
float64      u8WLRWheelSpd
float64      u8WRRWheelSpd
float64      u8WGearSpd
uint8        u1LFWheelRotatedDir
uint8        u1LRWheelRotatedDir
uint8        u1RFWheelRotatedDir
uint8        u1RRWheelRotatedDir
uint8        u1BrakePedalStatus
uint8        u1VehicleDir
uint8        u1BrkType
int8         u1Gear 
================================================================================
MSG: RosAdapter/mil_ego_state
# /** ------ MIL测试主车信息描述包 ------ */

object_state   sObjectState
float64        u4initSpeed
float64        u8DistRoadEnd
uint32         u4LightMask               
float32        u4WheelSpeedFL
float32        u4WheelSpeedFR
float32        u4WheelSpeedRL
float32        u4WheelSpeedRR
float32        u4MasterCylinderPressure
float32        u4WheelHeightLF
float32        u4WheelHeightLR
float32        u4WheelHeightRF
float32        u4WheelHeightRR
float32        u4SteerAngle
uint8          u1objQuantity
uint8          u1irc_id
uint8          u1irc_left_id
uint8          u1irc_right_id
uint8          u1cipv_id
uint8          u1lmc_id
uint8          u1rmc_id
uint8          u1isReachInitSpeed
================================================================================
MSG: RosAdapter/object_state
# /** ------ 对象信息 ------ */
coord           sSpeed
coord           sAccel
geometry        sGeo
coord           sPos
string          au1Name
string          au1ModelFileName
string          au1ModelName
float64[]       au8ParamScale
uint64          u8RoadId
float64         u8SpeedLimit
uint32          u4Id
float32         u4RoadS
float32         u4RoadT
float32         u4HdgRel
float32         u4LaneOffset
float32         u4TraveledDist
uint16          u2visMask
uint8           u1Type
int8            u1LaneId
uint8           u1Dir
bool            u1IsOnRoad
uint8           u1category
================================================================================
MSG: RosAdapter/coord
# /** ------ 坐标 ------ */
float64   u8X
float64   u8Y
float64   u8Z
float32   u4H
float32   u4P
float32   u4R
uint8     u1Type
================================================================================
MSG: RosAdapter/geometry
# /** ------ 几何信息 ------ */
float32 u4DimX
float32 u4DimY
float32 u4DimZ
float32 u4OffX
float32 u4OffY
float32 u4OffZ
================================================================================
MSG: RosAdapter/csv_data
# /** ------ AD发送给simpro的CSV数据 ------ */

float32  u4AccelTgt
float32  u4SteeringWheel
uint32   u4ADStatus
================================================================================
MSG: RosAdapter/v2x_warninginformation
# /** ------ V2X 告警信息 ------ */

uint32 u4Type
================================================================================
MSG: RosAdapter/obu_vnfp_info
uint32   type
================================================================================
MSG: RosAdapter/ad_signal_data
string      au1SignalName
float64     u8SignalValue
================================================================================
MSG: RosAdapter/ttc_control
uint32  u4Status"""
  __slots__ = ['head','driverCtrl','egoState','csvData','v2xWarning','obuVnfpInfo','adSignalDatas','ttcControl']
  _slot_types = ['RosAdapter/header','RosAdapter/driver_ctrl','RosAdapter/mil_ego_state','RosAdapter/csv_data','RosAdapter/v2x_warninginformation','RosAdapter/obu_vnfp_info','RosAdapter/ad_signal_data','RosAdapter/ttc_control']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       head,driverCtrl,egoState,csvData,v2xWarning,obuVnfpInfo,adSignalDatas,ttcControl

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(rosADToSimproDriverCtrl, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.driverCtrl is None:
        self.driverCtrl = RosAdapter.msg.driver_ctrl()
      if self.egoState is None:
        self.egoState = RosAdapter.msg.mil_ego_state()
      if self.csvData is None:
        self.csvData = RosAdapter.msg.csv_data()
      if self.v2xWarning is None:
        self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      if self.obuVnfpInfo is None:
        self.obuVnfpInfo = RosAdapter.msg.obu_vnfp_info()
      if self.adSignalDatas is None:
        self.adSignalDatas = RosAdapter.msg.ad_signal_data()
      if self.ttcControl is None:
        self.ttcControl = RosAdapter.msg.ttc_control()
    else:
      self.head = RosAdapter.msg.header()
      self.driverCtrl = RosAdapter.msg.driver_ctrl()
      self.egoState = RosAdapter.msg.mil_ego_state()
      self.csvData = RosAdapter.msg.csv_data()
      self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      self.obuVnfpInfo = RosAdapter.msg.obu_vnfp_info()
      self.adSignalDatas = RosAdapter.msg.ad_signal_data()
      self.ttcControl = RosAdapter.msg.ttc_control()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_d4If35d7Bb3d3fB3d3fB6f3d3fB().pack(_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.driverCtrl.u4ObjectId, _x.driverCtrl.u4MtWheel, _x.driverCtrl.u8MasterCylinderPressure, _x.driverCtrl.u8SteeringWheel, _x.driverCtrl.u8ThrottlePedal, _x.driverCtrl.u8BrakePedal, _x.driverCtrl.u8AccelTgt, _x.driverCtrl.u8SteeringTorque, _x.driverCtrl.u8StopDistance, _x.driverCtrl.u8TargetSpeed, _x.driverCtrl.u8Vx, _x.driverCtrl.u8Wr, _x.driverCtrl.u8VLFWheelSpd, _x.driverCtrl.u8VRFWheelSpd, _x.driverCtrl.u8VLRWheelSpd, _x.driverCtrl.u8VRRWheelSpd, _x.driverCtrl.u8Ax, _x.driverCtrl.u8Ay, _x.driverCtrl.u8SteeringWheelAngularRate, _x.driverCtrl.u8DrvTorqAct, _x.driverCtrl.u8Xmc, _x.driverCtrl.u8Ymc, _x.driverCtrl.u8YawThetaVehicle, _x.driverCtrl.u8PitchThetaVehicle, _x.driverCtrl.u8RollThetaVehicle, _x.driverCtrl.u8PitchRateVehicle, _x.driverCtrl.u8RollRateVehicle, _x.driverCtrl.u8SinSlopeout, _x.driverCtrl.u8VehicleCurv, _x.driverCtrl.u8TmotorCmd, _x.driverCtrl.u8Tmotor, _x.driverCtrl.u8EnergySourceLevel, _x.driverCtrl.u8WLFWheelSpd, _x.driverCtrl.u8WRFWheelSpd, _x.driverCtrl.u8WLRWheelSpd, _x.driverCtrl.u8WRRWheelSpd, _x.driverCtrl.u8WGearSpd, _x.driverCtrl.u1LFWheelRotatedDir, _x.driverCtrl.u1LRWheelRotatedDir, _x.driverCtrl.u1RFWheelRotatedDir, _x.driverCtrl.u1RRWheelRotatedDir, _x.driverCtrl.u1BrakePedalStatus, _x.driverCtrl.u1VehicleDir, _x.driverCtrl.u1BrkType, _x.driverCtrl.u1Gear, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type))
      _x = self.egoState.sObjectState.au1Name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelFileName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.egoState.sObjectState.au8ParamScale)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.egoState.sObjectState.au8ParamScale))
      _x = self
      buff.write(_get_struct_QdI5fHBb3B2dI10f8B2f3I().pack(_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type, _x.obuVnfpInfo.type))
      _x = self.adSignalDatas.au1SignalName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_dI().pack(_x.adSignalDatas.u8SignalValue, _x.ttcControl.u4Status))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.driverCtrl is None:
        self.driverCtrl = RosAdapter.msg.driver_ctrl()
      if self.egoState is None:
        self.egoState = RosAdapter.msg.mil_ego_state()
      if self.csvData is None:
        self.csvData = RosAdapter.msg.csv_data()
      if self.v2xWarning is None:
        self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      if self.obuVnfpInfo is None:
        self.obuVnfpInfo = RosAdapter.msg.obu_vnfp_info()
      if self.adSignalDatas is None:
        self.adSignalDatas = RosAdapter.msg.ad_signal_data()
      if self.ttcControl is None:
        self.ttcControl = RosAdapter.msg.ttc_control()
      end = 0
      _x = self
      start = end
      end += 451
      (_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.driverCtrl.u4ObjectId, _x.driverCtrl.u4MtWheel, _x.driverCtrl.u8MasterCylinderPressure, _x.driverCtrl.u8SteeringWheel, _x.driverCtrl.u8ThrottlePedal, _x.driverCtrl.u8BrakePedal, _x.driverCtrl.u8AccelTgt, _x.driverCtrl.u8SteeringTorque, _x.driverCtrl.u8StopDistance, _x.driverCtrl.u8TargetSpeed, _x.driverCtrl.u8Vx, _x.driverCtrl.u8Wr, _x.driverCtrl.u8VLFWheelSpd, _x.driverCtrl.u8VRFWheelSpd, _x.driverCtrl.u8VLRWheelSpd, _x.driverCtrl.u8VRRWheelSpd, _x.driverCtrl.u8Ax, _x.driverCtrl.u8Ay, _x.driverCtrl.u8SteeringWheelAngularRate, _x.driverCtrl.u8DrvTorqAct, _x.driverCtrl.u8Xmc, _x.driverCtrl.u8Ymc, _x.driverCtrl.u8YawThetaVehicle, _x.driverCtrl.u8PitchThetaVehicle, _x.driverCtrl.u8RollThetaVehicle, _x.driverCtrl.u8PitchRateVehicle, _x.driverCtrl.u8RollRateVehicle, _x.driverCtrl.u8SinSlopeout, _x.driverCtrl.u8VehicleCurv, _x.driverCtrl.u8TmotorCmd, _x.driverCtrl.u8Tmotor, _x.driverCtrl.u8EnergySourceLevel, _x.driverCtrl.u8WLFWheelSpd, _x.driverCtrl.u8WRFWheelSpd, _x.driverCtrl.u8WLRWheelSpd, _x.driverCtrl.u8WRRWheelSpd, _x.driverCtrl.u8WGearSpd, _x.driverCtrl.u1LFWheelRotatedDir, _x.driverCtrl.u1LRWheelRotatedDir, _x.driverCtrl.u1RFWheelRotatedDir, _x.driverCtrl.u1RRWheelRotatedDir, _x.driverCtrl.u1BrakePedalStatus, _x.driverCtrl.u1VehicleDir, _x.driverCtrl.u1BrkType, _x.driverCtrl.u1Gear, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type,) = _get_struct_d4If35d7Bb3d3fB3d3fB6f3d3fB().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1Name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1Name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelFileName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoState.sObjectState.au8ParamScale = s.unpack(str[start:end])
      _x = self
      start = end
      end += 135
      (_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type, _x.obuVnfpInfo.type,) = _get_struct_QdI5fHBb3B2dI10f8B2f3I().unpack(str[start:end])
      self.egoState.sObjectState.u1IsOnRoad = bool(self.egoState.sObjectState.u1IsOnRoad)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.adSignalDatas.au1SignalName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.adSignalDatas.au1SignalName = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.adSignalDatas.u8SignalValue, _x.ttcControl.u4Status,) = _get_struct_dI().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_d4If35d7Bb3d3fB3d3fB6f3d3fB().pack(_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.driverCtrl.u4ObjectId, _x.driverCtrl.u4MtWheel, _x.driverCtrl.u8MasterCylinderPressure, _x.driverCtrl.u8SteeringWheel, _x.driverCtrl.u8ThrottlePedal, _x.driverCtrl.u8BrakePedal, _x.driverCtrl.u8AccelTgt, _x.driverCtrl.u8SteeringTorque, _x.driverCtrl.u8StopDistance, _x.driverCtrl.u8TargetSpeed, _x.driverCtrl.u8Vx, _x.driverCtrl.u8Wr, _x.driverCtrl.u8VLFWheelSpd, _x.driverCtrl.u8VRFWheelSpd, _x.driverCtrl.u8VLRWheelSpd, _x.driverCtrl.u8VRRWheelSpd, _x.driverCtrl.u8Ax, _x.driverCtrl.u8Ay, _x.driverCtrl.u8SteeringWheelAngularRate, _x.driverCtrl.u8DrvTorqAct, _x.driverCtrl.u8Xmc, _x.driverCtrl.u8Ymc, _x.driverCtrl.u8YawThetaVehicle, _x.driverCtrl.u8PitchThetaVehicle, _x.driverCtrl.u8RollThetaVehicle, _x.driverCtrl.u8PitchRateVehicle, _x.driverCtrl.u8RollRateVehicle, _x.driverCtrl.u8SinSlopeout, _x.driverCtrl.u8VehicleCurv, _x.driverCtrl.u8TmotorCmd, _x.driverCtrl.u8Tmotor, _x.driverCtrl.u8EnergySourceLevel, _x.driverCtrl.u8WLFWheelSpd, _x.driverCtrl.u8WRFWheelSpd, _x.driverCtrl.u8WLRWheelSpd, _x.driverCtrl.u8WRRWheelSpd, _x.driverCtrl.u8WGearSpd, _x.driverCtrl.u1LFWheelRotatedDir, _x.driverCtrl.u1LRWheelRotatedDir, _x.driverCtrl.u1RFWheelRotatedDir, _x.driverCtrl.u1RRWheelRotatedDir, _x.driverCtrl.u1BrakePedalStatus, _x.driverCtrl.u1VehicleDir, _x.driverCtrl.u1BrkType, _x.driverCtrl.u1Gear, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type))
      _x = self.egoState.sObjectState.au1Name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelFileName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.egoState.sObjectState.au8ParamScale)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.egoState.sObjectState.au8ParamScale.tostring())
      _x = self
      buff.write(_get_struct_QdI5fHBb3B2dI10f8B2f3I().pack(_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type, _x.obuVnfpInfo.type))
      _x = self.adSignalDatas.au1SignalName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_dI().pack(_x.adSignalDatas.u8SignalValue, _x.ttcControl.u4Status))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.driverCtrl is None:
        self.driverCtrl = RosAdapter.msg.driver_ctrl()
      if self.egoState is None:
        self.egoState = RosAdapter.msg.mil_ego_state()
      if self.csvData is None:
        self.csvData = RosAdapter.msg.csv_data()
      if self.v2xWarning is None:
        self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      if self.obuVnfpInfo is None:
        self.obuVnfpInfo = RosAdapter.msg.obu_vnfp_info()
      if self.adSignalDatas is None:
        self.adSignalDatas = RosAdapter.msg.ad_signal_data()
      if self.ttcControl is None:
        self.ttcControl = RosAdapter.msg.ttc_control()
      end = 0
      _x = self
      start = end
      end += 451
      (_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.driverCtrl.u4ObjectId, _x.driverCtrl.u4MtWheel, _x.driverCtrl.u8MasterCylinderPressure, _x.driverCtrl.u8SteeringWheel, _x.driverCtrl.u8ThrottlePedal, _x.driverCtrl.u8BrakePedal, _x.driverCtrl.u8AccelTgt, _x.driverCtrl.u8SteeringTorque, _x.driverCtrl.u8StopDistance, _x.driverCtrl.u8TargetSpeed, _x.driverCtrl.u8Vx, _x.driverCtrl.u8Wr, _x.driverCtrl.u8VLFWheelSpd, _x.driverCtrl.u8VRFWheelSpd, _x.driverCtrl.u8VLRWheelSpd, _x.driverCtrl.u8VRRWheelSpd, _x.driverCtrl.u8Ax, _x.driverCtrl.u8Ay, _x.driverCtrl.u8SteeringWheelAngularRate, _x.driverCtrl.u8DrvTorqAct, _x.driverCtrl.u8Xmc, _x.driverCtrl.u8Ymc, _x.driverCtrl.u8YawThetaVehicle, _x.driverCtrl.u8PitchThetaVehicle, _x.driverCtrl.u8RollThetaVehicle, _x.driverCtrl.u8PitchRateVehicle, _x.driverCtrl.u8RollRateVehicle, _x.driverCtrl.u8SinSlopeout, _x.driverCtrl.u8VehicleCurv, _x.driverCtrl.u8TmotorCmd, _x.driverCtrl.u8Tmotor, _x.driverCtrl.u8EnergySourceLevel, _x.driverCtrl.u8WLFWheelSpd, _x.driverCtrl.u8WRFWheelSpd, _x.driverCtrl.u8WLRWheelSpd, _x.driverCtrl.u8WRRWheelSpd, _x.driverCtrl.u8WGearSpd, _x.driverCtrl.u1LFWheelRotatedDir, _x.driverCtrl.u1LRWheelRotatedDir, _x.driverCtrl.u1RFWheelRotatedDir, _x.driverCtrl.u1RRWheelRotatedDir, _x.driverCtrl.u1BrakePedalStatus, _x.driverCtrl.u1VehicleDir, _x.driverCtrl.u1BrkType, _x.driverCtrl.u1Gear, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type,) = _get_struct_d4If35d7Bb3d3fB3d3fB6f3d3fB().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1Name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1Name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelFileName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoState.sObjectState.au8ParamScale = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 135
      (_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type, _x.obuVnfpInfo.type,) = _get_struct_QdI5fHBb3B2dI10f8B2f3I().unpack(str[start:end])
      self.egoState.sObjectState.u1IsOnRoad = bool(self.egoState.sObjectState.u1IsOnRoad)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.adSignalDatas.au1SignalName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.adSignalDatas.au1SignalName = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.adSignalDatas.u8SignalValue, _x.ttcControl.u4Status,) = _get_struct_dI().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_QdI5fHBb3B2dI10f8B2f3I = None
def _get_struct_QdI5fHBb3B2dI10f8B2f3I():
    global _struct_QdI5fHBb3B2dI10f8B2f3I
    if _struct_QdI5fHBb3B2dI10f8B2f3I is None:
        _struct_QdI5fHBb3B2dI10f8B2f3I = struct.Struct("<QdI5fHBb3B2dI10f8B2f3I")
    return _struct_QdI5fHBb3B2dI10f8B2f3I
_struct_d4If35d7Bb3d3fB3d3fB6f3d3fB = None
def _get_struct_d4If35d7Bb3d3fB3d3fB6f3d3fB():
    global _struct_d4If35d7Bb3d3fB3d3fB6f3d3fB
    if _struct_d4If35d7Bb3d3fB3d3fB6f3d3fB is None:
        _struct_d4If35d7Bb3d3fB3d3fB6f3d3fB = struct.Struct("<d4If35d7Bb3d3fB3d3fB6f3d3fB")
    return _struct_d4If35d7Bb3d3fB3d3fB6f3d3fB
_struct_dI = None
def _get_struct_dI():
    global _struct_dI
    if _struct_dI is None:
        _struct_dI = struct.Struct("<dI")
    return _struct_dI
