# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from RosAdapter/rosSimproToAD.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import RosAdapter.msg

class rosSimproToAD(genpy.Message):
  _md5sum = "c51422c0a9306e26c68900e995989ad4"
  _type = "RosAdapter/rosSimproToAD"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# simpro发送给AD的数据
header                         head
lane_info[]                    laneInfos
sensor_info[]                  sensorStates
sensor_detection_info[]        sensorObjects
contact_point[]                contactPoints
traffic_sign[]                 trafficSigns
road_state[]                   roadStates
environment[]                  environments
traffic_light[]                trafficLights
road_query[]                   roadQueries
mil_ego_state[]                egoStates
mil_object_state[]             milObjStates
mil_roadmark[]                 milRoadMarks
init_param[]                   initParams
mil_amesim_signal[]            milAmesimSignals
activate_controller[]          activateControllers
assign_controller[]            assignControllers
override_controller[]          overrideControllers
custom_command[]               customCommands
parkingSpace[]                 parkingSpaces
driver_ctrl[]                  driverCtrls
sync[]                         syncs   
imu_data[]                     imuDatas     
gnss_gga[]                     gnssGgaS
uwb_data[]                     uwbDatas
model_outline[]                modelOutlines
rsu_vnfp_info                  rsuVnfpInfo
================================================================================
MSG: RosAdapter/header
# /** ------ Msg header ------ */
float64 u8SimTime
uint32  u4HeaderSize
uint32  u4DataSize
uint32  u4FrameNo
================================================================================
MSG: RosAdapter/lane_info
# /** ------ 车道信息 ------ */
uint64   u8RoadId
uint32   u4ObjectId
float32  u4Width
uint16   u2Type
int8     u1Id
uint8    u1NeighborMask
int8     u1LeftLaneId
int8     u1RightLaneId
================================================================================
MSG: RosAdapter/sensor_info
# /** ------ 传感器定义和状态 ------ */
coord      sPos
coord      sOriginCoordSys
string     au1Name
uint32     u8HostId
uint32     u8Id
float32[]  au4FovHV
float32[]  au4ClipNF
float32[]  au4FovOffHV
uint8      u1Type                   
uint8      u1ModelType
float64	   u4IdealFreq
uint32	   u4ResL
uint32     u4ResV
float64	   u4SenSizeL
float64	   u4SenSizeW
float64	   u4LenFd
float64	   u4DistCenL
float64	   u4DistCenW
float64	   u4DistParK1
float64	   u4DistParK2

================================================================================
MSG: RosAdapter/coord
# /** ------ 坐标 ------ */
float64   u8X
float64   u8Y
float64   u8Z
float32   u4H
float32   u4P
float32   u4R
uint8     u1Type
================================================================================
MSG: RosAdapter/sensor_detection_info
# 传感器监测物体所有信息

uint32            u4Id
uint32            u4SensorId
uint16            u2Flags
uint8             u1Type
int8              u1Occlusion
int8              u1DeltaLanePos
uint8             u1ValidFlag
float64           u8ExistProb
float64           u8TypeIdProb
object_uion       sExtraInfo
================================================================================
MSG: RosAdapter/object_uion
dynamic_object sDynamicObj
mark_object    sMarkObj
sign_object    sSignObj 
================================================================================
MSG: RosAdapter/dynamic_object
# /** ------ 传感器探测到的对象信息 ------ */

float64    u8Dist
float64    u8NearestDist
float64    u8RelativeVelx
float64    u8RelativeVely
float64    u8RelativeAccx
float64    u8RelativeAccy
float64    u8HeadingAngle
coord      sSensorPos
coord      sNearestSensorPos
coord      sSenNearestPosXL
coord      sSenNearestPosXR
coord      sSenNearestPosYL
coord      sSenNearestPosYR
point3d[]  sBoundingBox
uint8      u1MovingSt
================================================================================
MSG: RosAdapter/point3d
float64      u8x
float64      u8y
float64      u8z
================================================================================
MSG: RosAdapter/mark_object
# 车道线

float64[]	 au8RoadMarkCoeffL
float64[]	 au8RoadMarkCoeffR
================================================================================
MSG: RosAdapter/sign_object
# 交通标志

float64   u8Dist
float64   u8NearestDist
float64   u8TrafficSignDistX
float64   u8TrafficSignDistY
coord     sSensorPos
coord     sNearestSensorPos
uint8     u1TrafficSignType
================================================================================
MSG: RosAdapter/contact_point
# /** ------ 接触点信息 ------ */
coord  sRoadDataIn
uint16 u2Id
================================================================================
MSG: RosAdapter/traffic_sign
# /** ------ 交通标志信息 ------ */
string  au1Type
coord   sPos
uint32  u4TrafficSignId
uint32  u4ObjectId
string  au1SubType
float32 u4RoadDist
float32 u4Value
int8    u1MinLane
int8    u1MaxLane
================================================================================
MSG: RosAdapter/road_state
#/** ------ 车辆对应的道路状态 ------ */
uint64  u8RoadId
uint32  u4ObjectId
float32 u4DefaultSpeed
float32 u4WaterLevel
float32 u4DistToJunc
================================================================================
MSG: RosAdapter/environment
# /** ------ 环境信息 ------ */
float64      u8RainIntensity
float64      u8SnowIntensity
float64      u8FogIntensity
float64      u8FogVisualRange
uint32       u4TimeOfDay
int16        u2TimeZoneMinutesWest
uint16       u2Year
uint8        u1CloudState
uint8        u1Day
uint8        u1Month
================================================================================
MSG: RosAdapter/traffic_light
# /** ------ 交通灯信息 ------ */
int32                    u4Id
int32                    u4CtrlId
uint32                   u4NoPhases
uint32                   u4DataSize
float32                  u4State
float32                  u4CycleTime
traffic_light_phase[]    phases
================================================================================
MSG: RosAdapter/traffic_light_phase
# /** ------ 交通灯相位信息 ------ */

float32     u4Duration
uint8       u1Status   
================================================================================
MSG: RosAdapter/road_query
# /** ------ 查询道路点 ------ */
float32 u8X
float32 u8Y
uint16  u2Id
================================================================================
MSG: RosAdapter/mil_ego_state
# /** ------ MIL测试主车信息描述包 ------ */

object_state   sObjectState
float64        u4initSpeed
float64        u8DistRoadEnd
uint32         u4LightMask               
float32        u4WheelSpeedFL
float32        u4WheelSpeedFR
float32        u4WheelSpeedRL
float32        u4WheelSpeedRR
float32        u4MasterCylinderPressure
float32        u4WheelHeightLF
float32        u4WheelHeightLR
float32        u4WheelHeightRF
float32        u4WheelHeightRR
float32        u4SteerAngle
uint8          u1objQuantity
uint8          u1irc_id
uint8          u1irc_left_id
uint8          u1irc_right_id
uint8          u1cipv_id
uint8          u1lmc_id
uint8          u1rmc_id
uint8          u1isReachInitSpeed
================================================================================
MSG: RosAdapter/object_state
# /** ------ 对象信息 ------ */
coord           sSpeed
coord           sAccel
geometry        sGeo
coord           sPos
string          au1Name
string          au1ModelFileName
string          au1ModelName
float64[]       au8ParamScale
uint64          u8RoadId
float64         u8SpeedLimit
uint32          u4Id
float32         u4RoadS
float32         u4RoadT
float32         u4HdgRel
float32         u4LaneOffset
float32         u4TraveledDist
uint16          u2visMask
uint8           u1Type
int8            u1LaneId
uint8           u1Dir
bool            u1IsOnRoad
uint8           u1category
================================================================================
MSG: RosAdapter/geometry
# /** ------ 几何信息 ------ */
float32 u4DimX
float32 u4DimY
float32 u4DimZ
float32 u4OffX
float32 u4OffY
float32 u4OffZ
================================================================================
MSG: RosAdapter/mil_object_state
# /** ------ MIL测试环境车、行人、障碍物信息 ------ */
object_state           sObjectState
mil_object_state_base  sMilBase
================================================================================
MSG: RosAdapter/mil_object_state_base
#/** ------ MIL测试环境车、行人、障碍物信息描述包 ------ */

uint32     u4LightMask
float32    u4DistanceX
float32    u4DistanceY
float32    u4VelocityX
float32    u4VelocityY
float32    u4AccelerationX
float32    u4AccelerationY
float32    u4YawRate
float32    u4Dist
float32    u4Angle
uint8      u1ObjClass
uint8      u1Flag_detected
uint8      u1Movable
uint8      u1Moving
uint8      u1Obj_Age
================================================================================
MSG: RosAdapter/mil_roadmark
 # /** ------ MIL测试车道线信息描述包 ------ */

uint64  u8RoadId
float64 curvVert
float32 u4StartDx
float32 u4Width
float32 u4ViewRangeStart
float32 u4ViewRangeEnd
float32 u4MeasuredVREnd
float32 u4C0
float32 u4C1
float32 u4C2
float32 u4C3
uint16  u2LaneChange
int8    u1LaneId
uint8   u1Quality
uint8   u1Type
uint8   u1Color
uint8   u1LeftCrossing
uint8   u1RightCrossing
================================================================================
MSG: RosAdapter/init_param
# /** ------ 初始化参数 ------ */

string             au1OpenScenario
string             au1OpenDrive
uint64             u8StartRoadId
uint64             u8EndRoadId
float32            u4StartRoadS
float32            u4EndRoadS
float32            u4Speed
uint16             u2ScenarioId
int8               u1StartLaneId
int8               u1EndLaneId
================================================================================
MSG: RosAdapter/mil_amesim_signal
# /** ------ MIL AMESim 测试信息描述包 ------ */

float32       u4LeftLen
float32       u4NextLen
float32       u4NextAgeSpeed
float32       u4NextMinSpeed
float32       u4NextMaxSpeed
float32       u4NextGradient
float32       u4NextCongest
uint8         u1RoadType
float32       u4DisLimit
bool          u1IsFarAwayLimit
float32       u4LimitSpeed
bool          ulIsJunction
float32       u4DisJunction
bool          ulIsFarAwayJunc
uint8         ultrafficLightStat
float32       u4Curvity
float32       u4RelativeVel
float32       u4RelativeDis
================================================================================
MSG: RosAdapter/activate_controller
# /** ------激活控制器 ------ */

uint32          u4ObjectId
bool            u1Lateral
bool            u1Longitudinal
================================================================================
MSG: RosAdapter/assign_controller
# /** ------分配控制器 ------ */

string                               au1ControllerName
uint32                               u4ObjectId
uint32                               u4PropertyNum
assign_controller_property[]         properties
================================================================================
MSG: RosAdapter/assign_controller_property
# /** ------分配控制器的属性信息 ------ */

string   au1Name
string   au1Value
================================================================================
MSG: RosAdapter/override_controller
# /** ------接管控制器 ------ */

float64   u8ThrottleValue
float64   u8BrakeValue
float64   u8SteeringWheelValue
float64   u8ParkingBrakeValue
float64   u8ClutchValue
float64   u8GearValue
uint32    u4ObjectId
bool      u1ThrottleActive
bool      u1BrakeActive
bool      u1SteeringWheelActive
bool      u1ParkingBrakeActive
bool      u1ClutchActive
bool      u1GearActive
================================================================================
MSG: RosAdapter/custom_command
# /** ------自定义指令 ------ */

string   au1Type
string   au1Command
uint32   u4ObjectId
================================================================================
MSG: RosAdapter/parkingSpace
#/** ------ 停车位信息 ------ */
geometry  sGeo
coord     sPos
float32   u4RoadS
float32   u4RoadT
uint64    u8SlotId

================================================================================
MSG: RosAdapter/driver_ctrl
# /** ------ 驾驶员控制输入的信息 ------ */

uint32       u4ObjectId
float32      u4MtWheel
float64      u8MasterCylinderPressure
float64      u8SteeringWheel
float64      u8ThrottlePedal
float64      u8BrakePedal
float64      u8AccelTgt
float64      u8SteeringTorque
float64      u8StopDistance
float64      u8TargetSpeed
float64      u8Vx
float64      u8Wr
float64      u8VLFWheelSpd
float64      u8VRFWheelSpd
float64      u8VLRWheelSpd
float64      u8VRRWheelSpd
float64      u8Ax
float64      u8Ay
float64      u8SteeringWheelAngularRate
float64      u8DrvTorqAct
float64      u8Xmc
float64      u8Ymc
float64      u8YawThetaVehicle
float64      u8PitchThetaVehicle
float64      u8RollThetaVehicle
float64      u8PitchRateVehicle
float64      u8RollRateVehicle
float64      u8SinSlopeout
float64      u8VehicleCurv
float64      u8TmotorCmd
float64      u8Tmotor
float64      u8EnergySourceLevel
float64      u8WLFWheelSpd
float64      u8WRFWheelSpd
float64      u8WLRWheelSpd
float64      u8WRRWheelSpd
float64      u8WGearSpd
uint8        u1LFWheelRotatedDir
uint8        u1LRWheelRotatedDir
uint8        u1RFWheelRotatedDir
uint8        u1RRWheelRotatedDir
uint8        u1BrakePedalStatus
uint8        u1VehicleDir
uint8        u1BrkType
int8         u1Gear 
================================================================================
MSG: RosAdapter/sync
# /** ------ 同步信号 ------ */
uint32 u4CmdMask
uint32 u4UserData
================================================================================
MSG: RosAdapter/imu_data
uint8         msgcnt
float64       u8X
float64       u8Y
float64       u8Z
float64       yaw
float64       pitch
float64       roll
================================================================================
MSG: RosAdapter/gnss_gga
uint8         startChar
uint8[]       cmd
uint8[]       mTime
float64       lat
uint8         NorS
float64       lon
uint8         EorW
uint8[]       mode
int32         count
float64       horizonprecious 
float64       geoidalheight
uint8         meter1
float64       height
uint8         meter2
float64       dataage
int32         basestationflag
uint8         sperator
uint8[]       checksum
================================================================================
MSG: RosAdapter/uwb_data
uint8         msgcnt
float64       u8x
float64       u8y
float64       u8z
================================================================================
MSG: RosAdapter/model_outline
string                au1ModelName
double_array[]        au8OutlinePoints    
================================================================================
MSG: RosAdapter/double_array
float64[]  data
================================================================================
MSG: RosAdapter/rsu_vnfp_info
uint32    type"""
  __slots__ = ['head','laneInfos','sensorStates','sensorObjects','contactPoints','trafficSigns','roadStates','environments','trafficLights','roadQueries','egoStates','milObjStates','milRoadMarks','initParams','milAmesimSignals','activateControllers','assignControllers','overrideControllers','customCommands','parkingSpaces','driverCtrls','syncs','imuDatas','gnssGgaS','uwbDatas','modelOutlines','rsuVnfpInfo']
  _slot_types = ['RosAdapter/header','RosAdapter/lane_info[]','RosAdapter/sensor_info[]','RosAdapter/sensor_detection_info[]','RosAdapter/contact_point[]','RosAdapter/traffic_sign[]','RosAdapter/road_state[]','RosAdapter/environment[]','RosAdapter/traffic_light[]','RosAdapter/road_query[]','RosAdapter/mil_ego_state[]','RosAdapter/mil_object_state[]','RosAdapter/mil_roadmark[]','RosAdapter/init_param[]','RosAdapter/mil_amesim_signal[]','RosAdapter/activate_controller[]','RosAdapter/assign_controller[]','RosAdapter/override_controller[]','RosAdapter/custom_command[]','RosAdapter/parkingSpace[]','RosAdapter/driver_ctrl[]','RosAdapter/sync[]','RosAdapter/imu_data[]','RosAdapter/gnss_gga[]','RosAdapter/uwb_data[]','RosAdapter/model_outline[]','RosAdapter/rsu_vnfp_info']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       head,laneInfos,sensorStates,sensorObjects,contactPoints,trafficSigns,roadStates,environments,trafficLights,roadQueries,egoStates,milObjStates,milRoadMarks,initParams,milAmesimSignals,activateControllers,assignControllers,overrideControllers,customCommands,parkingSpaces,driverCtrls,syncs,imuDatas,gnssGgaS,uwbDatas,modelOutlines,rsuVnfpInfo

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(rosSimproToAD, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.laneInfos is None:
        self.laneInfos = []
      if self.sensorStates is None:
        self.sensorStates = []
      if self.sensorObjects is None:
        self.sensorObjects = []
      if self.contactPoints is None:
        self.contactPoints = []
      if self.trafficSigns is None:
        self.trafficSigns = []
      if self.roadStates is None:
        self.roadStates = []
      if self.environments is None:
        self.environments = []
      if self.trafficLights is None:
        self.trafficLights = []
      if self.roadQueries is None:
        self.roadQueries = []
      if self.egoStates is None:
        self.egoStates = []
      if self.milObjStates is None:
        self.milObjStates = []
      if self.milRoadMarks is None:
        self.milRoadMarks = []
      if self.initParams is None:
        self.initParams = []
      if self.milAmesimSignals is None:
        self.milAmesimSignals = []
      if self.activateControllers is None:
        self.activateControllers = []
      if self.assignControllers is None:
        self.assignControllers = []
      if self.overrideControllers is None:
        self.overrideControllers = []
      if self.customCommands is None:
        self.customCommands = []
      if self.parkingSpaces is None:
        self.parkingSpaces = []
      if self.driverCtrls is None:
        self.driverCtrls = []
      if self.syncs is None:
        self.syncs = []
      if self.imuDatas is None:
        self.imuDatas = []
      if self.gnssGgaS is None:
        self.gnssGgaS = []
      if self.uwbDatas is None:
        self.uwbDatas = []
      if self.modelOutlines is None:
        self.modelOutlines = []
      if self.rsuVnfpInfo is None:
        self.rsuVnfpInfo = RosAdapter.msg.rsu_vnfp_info()
    else:
      self.head = RosAdapter.msg.header()
      self.laneInfos = []
      self.sensorStates = []
      self.sensorObjects = []
      self.contactPoints = []
      self.trafficSigns = []
      self.roadStates = []
      self.environments = []
      self.trafficLights = []
      self.roadQueries = []
      self.egoStates = []
      self.milObjStates = []
      self.milRoadMarks = []
      self.initParams = []
      self.milAmesimSignals = []
      self.activateControllers = []
      self.assignControllers = []
      self.overrideControllers = []
      self.customCommands = []
      self.parkingSpaces = []
      self.driverCtrls = []
      self.syncs = []
      self.imuDatas = []
      self.gnssGgaS = []
      self.uwbDatas = []
      self.modelOutlines = []
      self.rsuVnfpInfo = RosAdapter.msg.rsu_vnfp_info()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_d3I().pack(_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo))
      length = len(self.laneInfos)
      buff.write(_struct_I.pack(length))
      for val1 in self.laneInfos:
        _x = val1
        buff.write(_get_struct_QIfHbB2b().pack(_x.u8RoadId, _x.u4ObjectId, _x.u4Width, _x.u2Type, _x.u1Id, _x.u1NeighborMask, _x.u1LeftLaneId, _x.u1RightLaneId))
      length = len(self.sensorStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensorStates:
        _v1 = val1.sPos
        _x = _v1
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v2 = val1.sOriginCoordSys
        _x = _v2
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1.au1Name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u8HostId, _x.u8Id))
        length = len(val1.au4FovHV)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.Struct(pattern).pack(*val1.au4FovHV))
        length = len(val1.au4ClipNF)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.Struct(pattern).pack(*val1.au4ClipNF))
        length = len(val1.au4FovOffHV)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(struct.Struct(pattern).pack(*val1.au4FovOffHV))
        _x = val1
        buff.write(_get_struct_2Bd2I7d().pack(_x.u1Type, _x.u1ModelType, _x.u4IdealFreq, _x.u4ResL, _x.u4ResV, _x.u4SenSizeL, _x.u4SenSizeW, _x.u4LenFd, _x.u4DistCenL, _x.u4DistCenW, _x.u4DistParK1, _x.u4DistParK2))
      length = len(self.sensorObjects)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensorObjects:
        _x = val1
        buff.write(_get_struct_2IHB2bB2d().pack(_x.u4Id, _x.u4SensorId, _x.u2Flags, _x.u1Type, _x.u1Occlusion, _x.u1DeltaLanePos, _x.u1ValidFlag, _x.u8ExistProb, _x.u8TypeIdProb))
        _v3 = val1.sExtraInfo
        _v4 = _v3.sDynamicObj
        _x = _v4
        buff.write(_get_struct_7d().pack(_x.u8Dist, _x.u8NearestDist, _x.u8RelativeVelx, _x.u8RelativeVely, _x.u8RelativeAccx, _x.u8RelativeAccy, _x.u8HeadingAngle))
        _v5 = _v4.sSensorPos
        _x = _v5
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v6 = _v4.sNearestSensorPos
        _x = _v6
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v7 = _v4.sSenNearestPosXL
        _x = _v7
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v8 = _v4.sSenNearestPosXR
        _x = _v8
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v9 = _v4.sSenNearestPosYL
        _x = _v9
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v10 = _v4.sSenNearestPosYR
        _x = _v10
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        length = len(_v4.sBoundingBox)
        buff.write(_struct_I.pack(length))
        for val4 in _v4.sBoundingBox:
          _x = val4
          buff.write(_get_struct_3d().pack(_x.u8x, _x.u8y, _x.u8z))
        _x = _v4.u1MovingSt
        buff.write(_get_struct_B().pack(_x))
        _v11 = _v3.sMarkObj
        length = len(_v11.au8RoadMarkCoeffL)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v11.au8RoadMarkCoeffL))
        length = len(_v11.au8RoadMarkCoeffR)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v11.au8RoadMarkCoeffR))
        _v12 = _v3.sSignObj
        _x = _v12
        buff.write(_get_struct_4d().pack(_x.u8Dist, _x.u8NearestDist, _x.u8TrafficSignDistX, _x.u8TrafficSignDistY))
        _v13 = _v12.sSensorPos
        _x = _v13
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v14 = _v12.sNearestSensorPos
        _x = _v14
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = _v12.u1TrafficSignType
        buff.write(_get_struct_B().pack(_x))
      length = len(self.contactPoints)
      buff.write(_struct_I.pack(length))
      for val1 in self.contactPoints:
        _v15 = val1.sRoadDataIn
        _x = _v15
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1.u2Id
        buff.write(_get_struct_H().pack(_x))
      length = len(self.trafficSigns)
      buff.write(_struct_I.pack(length))
      for val1 in self.trafficSigns:
        _x = val1.au1Type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v16 = val1.sPos
        _x = _v16
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u4TrafficSignId, _x.u4ObjectId))
        _x = val1.au1SubType
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2f2b().pack(_x.u4RoadDist, _x.u4Value, _x.u1MinLane, _x.u1MaxLane))
      length = len(self.roadStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.roadStates:
        _x = val1
        buff.write(_get_struct_QI3f().pack(_x.u8RoadId, _x.u4ObjectId, _x.u4DefaultSpeed, _x.u4WaterLevel, _x.u4DistToJunc))
      length = len(self.environments)
      buff.write(_struct_I.pack(length))
      for val1 in self.environments:
        _x = val1
        buff.write(_get_struct_4dIhH3B().pack(_x.u8RainIntensity, _x.u8SnowIntensity, _x.u8FogIntensity, _x.u8FogVisualRange, _x.u4TimeOfDay, _x.u2TimeZoneMinutesWest, _x.u2Year, _x.u1CloudState, _x.u1Day, _x.u1Month))
      length = len(self.trafficLights)
      buff.write(_struct_I.pack(length))
      for val1 in self.trafficLights:
        _x = val1
        buff.write(_get_struct_2i2I2f().pack(_x.u4Id, _x.u4CtrlId, _x.u4NoPhases, _x.u4DataSize, _x.u4State, _x.u4CycleTime))
        length = len(val1.phases)
        buff.write(_struct_I.pack(length))
        for val2 in val1.phases:
          _x = val2
          buff.write(_get_struct_fB().pack(_x.u4Duration, _x.u1Status))
      length = len(self.roadQueries)
      buff.write(_struct_I.pack(length))
      for val1 in self.roadQueries:
        _x = val1
        buff.write(_get_struct_2fH().pack(_x.u8X, _x.u8Y, _x.u2Id))
      length = len(self.egoStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.egoStates:
        _v17 = val1.sObjectState
        _v18 = _v17.sSpeed
        _x = _v18
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v19 = _v17.sAccel
        _x = _v19
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v20 = _v17.sGeo
        _x = _v20
        buff.write(_get_struct_6f().pack(_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ))
        _v21 = _v17.sPos
        _x = _v21
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = _v17.au1Name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v17.au1ModelFileName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v17.au1ModelName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(_v17.au8ParamScale)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v17.au8ParamScale))
        _x = _v17
        buff.write(_get_struct_QdI5fHBb3B().pack(_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category))
        _x = val1
        buff.write(_get_struct_2dI10f8B().pack(_x.u4initSpeed, _x.u8DistRoadEnd, _x.u4LightMask, _x.u4WheelSpeedFL, _x.u4WheelSpeedFR, _x.u4WheelSpeedRL, _x.u4WheelSpeedRR, _x.u4MasterCylinderPressure, _x.u4WheelHeightLF, _x.u4WheelHeightLR, _x.u4WheelHeightRF, _x.u4WheelHeightRR, _x.u4SteerAngle, _x.u1objQuantity, _x.u1irc_id, _x.u1irc_left_id, _x.u1irc_right_id, _x.u1cipv_id, _x.u1lmc_id, _x.u1rmc_id, _x.u1isReachInitSpeed))
      length = len(self.milObjStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.milObjStates:
        _v22 = val1.sObjectState
        _v23 = _v22.sSpeed
        _x = _v23
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v24 = _v22.sAccel
        _x = _v24
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v25 = _v22.sGeo
        _x = _v25
        buff.write(_get_struct_6f().pack(_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ))
        _v26 = _v22.sPos
        _x = _v26
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = _v22.au1Name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v22.au1ModelFileName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v22.au1ModelName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(_v22.au8ParamScale)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(struct.Struct(pattern).pack(*_v22.au8ParamScale))
        _x = _v22
        buff.write(_get_struct_QdI5fHBb3B().pack(_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category))
        _v27 = val1.sMilBase
        _x = _v27
        buff.write(_get_struct_I9f5B().pack(_x.u4LightMask, _x.u4DistanceX, _x.u4DistanceY, _x.u4VelocityX, _x.u4VelocityY, _x.u4AccelerationX, _x.u4AccelerationY, _x.u4YawRate, _x.u4Dist, _x.u4Angle, _x.u1ObjClass, _x.u1Flag_detected, _x.u1Movable, _x.u1Moving, _x.u1Obj_Age))
      length = len(self.milRoadMarks)
      buff.write(_struct_I.pack(length))
      for val1 in self.milRoadMarks:
        _x = val1
        buff.write(_get_struct_Qd9fHb5B().pack(_x.u8RoadId, _x.curvVert, _x.u4StartDx, _x.u4Width, _x.u4ViewRangeStart, _x.u4ViewRangeEnd, _x.u4MeasuredVREnd, _x.u4C0, _x.u4C1, _x.u4C2, _x.u4C3, _x.u2LaneChange, _x.u1LaneId, _x.u1Quality, _x.u1Type, _x.u1Color, _x.u1LeftCrossing, _x.u1RightCrossing))
      length = len(self.initParams)
      buff.write(_struct_I.pack(length))
      for val1 in self.initParams:
        _x = val1.au1OpenScenario
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.au1OpenDrive
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2Q3fH2b().pack(_x.u8StartRoadId, _x.u8EndRoadId, _x.u4StartRoadS, _x.u4EndRoadS, _x.u4Speed, _x.u2ScenarioId, _x.u1StartLaneId, _x.u1EndLaneId))
      length = len(self.milAmesimSignals)
      buff.write(_struct_I.pack(length))
      for val1 in self.milAmesimSignals:
        _x = val1
        buff.write(_get_struct_7fBfBfBf2B3f().pack(_x.u4LeftLen, _x.u4NextLen, _x.u4NextAgeSpeed, _x.u4NextMinSpeed, _x.u4NextMaxSpeed, _x.u4NextGradient, _x.u4NextCongest, _x.u1RoadType, _x.u4DisLimit, _x.u1IsFarAwayLimit, _x.u4LimitSpeed, _x.ulIsJunction, _x.u4DisJunction, _x.ulIsFarAwayJunc, _x.ultrafficLightStat, _x.u4Curvity, _x.u4RelativeVel, _x.u4RelativeDis))
      length = len(self.activateControllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.activateControllers:
        _x = val1
        buff.write(_get_struct_I2B().pack(_x.u4ObjectId, _x.u1Lateral, _x.u1Longitudinal))
      length = len(self.assignControllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.assignControllers:
        _x = val1.au1ControllerName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u4ObjectId, _x.u4PropertyNum))
        length = len(val1.properties)
        buff.write(_struct_I.pack(length))
        for val2 in val1.properties:
          _x = val2.au1Name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val2.au1Value
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.overrideControllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.overrideControllers:
        _x = val1
        buff.write(_get_struct_6dI6B().pack(_x.u8ThrottleValue, _x.u8BrakeValue, _x.u8SteeringWheelValue, _x.u8ParkingBrakeValue, _x.u8ClutchValue, _x.u8GearValue, _x.u4ObjectId, _x.u1ThrottleActive, _x.u1BrakeActive, _x.u1SteeringWheelActive, _x.u1ParkingBrakeActive, _x.u1ClutchActive, _x.u1GearActive))
      length = len(self.customCommands)
      buff.write(_struct_I.pack(length))
      for val1 in self.customCommands:
        _x = val1.au1Type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.au1Command
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.u4ObjectId
        buff.write(_get_struct_I().pack(_x))
      length = len(self.parkingSpaces)
      buff.write(_struct_I.pack(length))
      for val1 in self.parkingSpaces:
        _v28 = val1.sGeo
        _x = _v28
        buff.write(_get_struct_6f().pack(_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ))
        _v29 = val1.sPos
        _x = _v29
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1
        buff.write(_get_struct_2fQ().pack(_x.u4RoadS, _x.u4RoadT, _x.u8SlotId))
      length = len(self.driverCtrls)
      buff.write(_struct_I.pack(length))
      for val1 in self.driverCtrls:
        _x = val1
        buff.write(_get_struct_If35d7Bb().pack(_x.u4ObjectId, _x.u4MtWheel, _x.u8MasterCylinderPressure, _x.u8SteeringWheel, _x.u8ThrottlePedal, _x.u8BrakePedal, _x.u8AccelTgt, _x.u8SteeringTorque, _x.u8StopDistance, _x.u8TargetSpeed, _x.u8Vx, _x.u8Wr, _x.u8VLFWheelSpd, _x.u8VRFWheelSpd, _x.u8VLRWheelSpd, _x.u8VRRWheelSpd, _x.u8Ax, _x.u8Ay, _x.u8SteeringWheelAngularRate, _x.u8DrvTorqAct, _x.u8Xmc, _x.u8Ymc, _x.u8YawThetaVehicle, _x.u8PitchThetaVehicle, _x.u8RollThetaVehicle, _x.u8PitchRateVehicle, _x.u8RollRateVehicle, _x.u8SinSlopeout, _x.u8VehicleCurv, _x.u8TmotorCmd, _x.u8Tmotor, _x.u8EnergySourceLevel, _x.u8WLFWheelSpd, _x.u8WRFWheelSpd, _x.u8WLRWheelSpd, _x.u8WRRWheelSpd, _x.u8WGearSpd, _x.u1LFWheelRotatedDir, _x.u1LRWheelRotatedDir, _x.u1RFWheelRotatedDir, _x.u1RRWheelRotatedDir, _x.u1BrakePedalStatus, _x.u1VehicleDir, _x.u1BrkType, _x.u1Gear))
      length = len(self.syncs)
      buff.write(_struct_I.pack(length))
      for val1 in self.syncs:
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u4CmdMask, _x.u4UserData))
      length = len(self.imuDatas)
      buff.write(_struct_I.pack(length))
      for val1 in self.imuDatas:
        _x = val1
        buff.write(_get_struct_B6d().pack(_x.msgcnt, _x.u8X, _x.u8Y, _x.u8Z, _x.yaw, _x.pitch, _x.roll))
      length = len(self.gnssGgaS)
      buff.write(_struct_I.pack(length))
      for val1 in self.gnssGgaS:
        _x = val1.startChar
        buff.write(_get_struct_B().pack(_x))
        _x = val1.cmd
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.mTime
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_dBdB().pack(_x.lat, _x.NorS, _x.lon, _x.EorW))
        _x = val1.mode
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_i2dBdBdiB().pack(_x.count, _x.horizonprecious, _x.geoidalheight, _x.meter1, _x.height, _x.meter2, _x.dataage, _x.basestationflag, _x.sperator))
        _x = val1.checksum
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.uwbDatas)
      buff.write(_struct_I.pack(length))
      for val1 in self.uwbDatas:
        _x = val1
        buff.write(_get_struct_B3d().pack(_x.msgcnt, _x.u8x, _x.u8y, _x.u8z))
      length = len(self.modelOutlines)
      buff.write(_struct_I.pack(length))
      for val1 in self.modelOutlines:
        _x = val1.au1ModelName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.au8OutlinePoints)
        buff.write(_struct_I.pack(length))
        for val2 in val1.au8OutlinePoints:
          length = len(val2.data)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(struct.Struct(pattern).pack(*val2.data))
      _x = self.rsuVnfpInfo.type
      buff.write(_get_struct_I().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.laneInfos is None:
        self.laneInfos = None
      if self.sensorStates is None:
        self.sensorStates = None
      if self.sensorObjects is None:
        self.sensorObjects = None
      if self.contactPoints is None:
        self.contactPoints = None
      if self.trafficSigns is None:
        self.trafficSigns = None
      if self.roadStates is None:
        self.roadStates = None
      if self.environments is None:
        self.environments = None
      if self.trafficLights is None:
        self.trafficLights = None
      if self.roadQueries is None:
        self.roadQueries = None
      if self.egoStates is None:
        self.egoStates = None
      if self.milObjStates is None:
        self.milObjStates = None
      if self.milRoadMarks is None:
        self.milRoadMarks = None
      if self.initParams is None:
        self.initParams = None
      if self.milAmesimSignals is None:
        self.milAmesimSignals = None
      if self.activateControllers is None:
        self.activateControllers = None
      if self.assignControllers is None:
        self.assignControllers = None
      if self.overrideControllers is None:
        self.overrideControllers = None
      if self.customCommands is None:
        self.customCommands = None
      if self.parkingSpaces is None:
        self.parkingSpaces = None
      if self.driverCtrls is None:
        self.driverCtrls = None
      if self.syncs is None:
        self.syncs = None
      if self.imuDatas is None:
        self.imuDatas = None
      if self.gnssGgaS is None:
        self.gnssGgaS = None
      if self.uwbDatas is None:
        self.uwbDatas = None
      if self.modelOutlines is None:
        self.modelOutlines = None
      if self.rsuVnfpInfo is None:
        self.rsuVnfpInfo = RosAdapter.msg.rsu_vnfp_info()
      end = 0
      _x = self
      start = end
      end += 20
      (_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo,) = _get_struct_d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.laneInfos = []
      for i in range(0, length):
        val1 = RosAdapter.msg.lane_info()
        _x = val1
        start = end
        end += 22
        (_x.u8RoadId, _x.u4ObjectId, _x.u4Width, _x.u2Type, _x.u1Id, _x.u1NeighborMask, _x.u1LeftLaneId, _x.u1RightLaneId,) = _get_struct_QIfHbB2b().unpack(str[start:end])
        self.laneInfos.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensorStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.sensor_info()
        _v30 = val1.sPos
        _x = _v30
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v31 = val1.sOriginCoordSys
        _x = _v31
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Name = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.u8HostId, _x.u8Id,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.au4FovHV = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.au4ClipNF = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.au4FovOffHV = s.unpack(str[start:end])
        _x = val1
        start = end
        end += 74
        (_x.u1Type, _x.u1ModelType, _x.u4IdealFreq, _x.u4ResL, _x.u4ResV, _x.u4SenSizeL, _x.u4SenSizeW, _x.u4LenFd, _x.u4DistCenL, _x.u4DistCenW, _x.u4DistParK1, _x.u4DistParK2,) = _get_struct_2Bd2I7d().unpack(str[start:end])
        self.sensorStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensorObjects = []
      for i in range(0, length):
        val1 = RosAdapter.msg.sensor_detection_info()
        _x = val1
        start = end
        end += 30
        (_x.u4Id, _x.u4SensorId, _x.u2Flags, _x.u1Type, _x.u1Occlusion, _x.u1DeltaLanePos, _x.u1ValidFlag, _x.u8ExistProb, _x.u8TypeIdProb,) = _get_struct_2IHB2bB2d().unpack(str[start:end])
        _v32 = val1.sExtraInfo
        _v33 = _v32.sDynamicObj
        _x = _v33
        start = end
        end += 56
        (_x.u8Dist, _x.u8NearestDist, _x.u8RelativeVelx, _x.u8RelativeVely, _x.u8RelativeAccx, _x.u8RelativeAccy, _x.u8HeadingAngle,) = _get_struct_7d().unpack(str[start:end])
        _v34 = _v33.sSensorPos
        _x = _v34
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v35 = _v33.sNearestSensorPos
        _x = _v35
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v36 = _v33.sSenNearestPosXL
        _x = _v36
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v37 = _v33.sSenNearestPosXR
        _x = _v37
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v38 = _v33.sSenNearestPosYL
        _x = _v38
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v39 = _v33.sSenNearestPosYR
        _x = _v39
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v33.sBoundingBox = []
        for i in range(0, length):
          val4 = RosAdapter.msg.point3d()
          _x = val4
          start = end
          end += 24
          (_x.u8x, _x.u8y, _x.u8z,) = _get_struct_3d().unpack(str[start:end])
          _v33.sBoundingBox.append(val4)
        start = end
        end += 1
        (_v33.u1MovingSt,) = _get_struct_B().unpack(str[start:end])
        _v40 = _v32.sMarkObj
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v40.au8RoadMarkCoeffL = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v40.au8RoadMarkCoeffR = s.unpack(str[start:end])
        _v41 = _v32.sSignObj
        _x = _v41
        start = end
        end += 32
        (_x.u8Dist, _x.u8NearestDist, _x.u8TrafficSignDistX, _x.u8TrafficSignDistY,) = _get_struct_4d().unpack(str[start:end])
        _v42 = _v41.sSensorPos
        _x = _v42
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v43 = _v41.sNearestSensorPos
        _x = _v43
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 1
        (_v41.u1TrafficSignType,) = _get_struct_B().unpack(str[start:end])
        self.sensorObjects.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.contactPoints = []
      for i in range(0, length):
        val1 = RosAdapter.msg.contact_point()
        _v44 = val1.sRoadDataIn
        _x = _v44
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 2
        (val1.u2Id,) = _get_struct_H().unpack(str[start:end])
        self.contactPoints.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trafficSigns = []
      for i in range(0, length):
        val1 = RosAdapter.msg.traffic_sign()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Type = str[start:end]
        _v45 = val1.sPos
        _x = _v45
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.u4TrafficSignId, _x.u4ObjectId,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1SubType = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1SubType = str[start:end]
        _x = val1
        start = end
        end += 10
        (_x.u4RoadDist, _x.u4Value, _x.u1MinLane, _x.u1MaxLane,) = _get_struct_2f2b().unpack(str[start:end])
        self.trafficSigns.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.roadStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.road_state()
        _x = val1
        start = end
        end += 24
        (_x.u8RoadId, _x.u4ObjectId, _x.u4DefaultSpeed, _x.u4WaterLevel, _x.u4DistToJunc,) = _get_struct_QI3f().unpack(str[start:end])
        self.roadStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.environments = []
      for i in range(0, length):
        val1 = RosAdapter.msg.environment()
        _x = val1
        start = end
        end += 43
        (_x.u8RainIntensity, _x.u8SnowIntensity, _x.u8FogIntensity, _x.u8FogVisualRange, _x.u4TimeOfDay, _x.u2TimeZoneMinutesWest, _x.u2Year, _x.u1CloudState, _x.u1Day, _x.u1Month,) = _get_struct_4dIhH3B().unpack(str[start:end])
        self.environments.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trafficLights = []
      for i in range(0, length):
        val1 = RosAdapter.msg.traffic_light()
        _x = val1
        start = end
        end += 24
        (_x.u4Id, _x.u4CtrlId, _x.u4NoPhases, _x.u4DataSize, _x.u4State, _x.u4CycleTime,) = _get_struct_2i2I2f().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.phases = []
        for i in range(0, length):
          val2 = RosAdapter.msg.traffic_light_phase()
          _x = val2
          start = end
          end += 5
          (_x.u4Duration, _x.u1Status,) = _get_struct_fB().unpack(str[start:end])
          val1.phases.append(val2)
        self.trafficLights.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.roadQueries = []
      for i in range(0, length):
        val1 = RosAdapter.msg.road_query()
        _x = val1
        start = end
        end += 10
        (_x.u8X, _x.u8Y, _x.u2Id,) = _get_struct_2fH().unpack(str[start:end])
        self.roadQueries.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.egoStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_ego_state()
        _v46 = val1.sObjectState
        _v47 = _v46.sSpeed
        _x = _v47
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v48 = _v46.sAccel
        _x = _v48
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v49 = _v46.sGeo
        _x = _v49
        start = end
        end += 24
        (_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ,) = _get_struct_6f().unpack(str[start:end])
        _v50 = _v46.sPos
        _x = _v50
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v46.au1Name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v46.au1Name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v46.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v46.au1ModelFileName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v46.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v46.au1ModelName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v46.au8ParamScale = s.unpack(str[start:end])
        _x = _v46
        start = end
        end += 47
        (_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category,) = _get_struct_QdI5fHBb3B().unpack(str[start:end])
        _v46.u1IsOnRoad = bool(_v46.u1IsOnRoad)
        _x = val1
        start = end
        end += 68
        (_x.u4initSpeed, _x.u8DistRoadEnd, _x.u4LightMask, _x.u4WheelSpeedFL, _x.u4WheelSpeedFR, _x.u4WheelSpeedRL, _x.u4WheelSpeedRR, _x.u4MasterCylinderPressure, _x.u4WheelHeightLF, _x.u4WheelHeightLR, _x.u4WheelHeightRF, _x.u4WheelHeightRR, _x.u4SteerAngle, _x.u1objQuantity, _x.u1irc_id, _x.u1irc_left_id, _x.u1irc_right_id, _x.u1cipv_id, _x.u1lmc_id, _x.u1rmc_id, _x.u1isReachInitSpeed,) = _get_struct_2dI10f8B().unpack(str[start:end])
        self.egoStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.milObjStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_object_state()
        _v51 = val1.sObjectState
        _v52 = _v51.sSpeed
        _x = _v52
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v53 = _v51.sAccel
        _x = _v53
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v54 = _v51.sGeo
        _x = _v54
        start = end
        end += 24
        (_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ,) = _get_struct_6f().unpack(str[start:end])
        _v55 = _v51.sPos
        _x = _v55
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v51.au1Name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v51.au1Name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v51.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v51.au1ModelFileName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v51.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v51.au1ModelName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v51.au8ParamScale = s.unpack(str[start:end])
        _x = _v51
        start = end
        end += 47
        (_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category,) = _get_struct_QdI5fHBb3B().unpack(str[start:end])
        _v51.u1IsOnRoad = bool(_v51.u1IsOnRoad)
        _v56 = val1.sMilBase
        _x = _v56
        start = end
        end += 45
        (_x.u4LightMask, _x.u4DistanceX, _x.u4DistanceY, _x.u4VelocityX, _x.u4VelocityY, _x.u4AccelerationX, _x.u4AccelerationY, _x.u4YawRate, _x.u4Dist, _x.u4Angle, _x.u1ObjClass, _x.u1Flag_detected, _x.u1Movable, _x.u1Moving, _x.u1Obj_Age,) = _get_struct_I9f5B().unpack(str[start:end])
        self.milObjStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.milRoadMarks = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_roadmark()
        _x = val1
        start = end
        end += 60
        (_x.u8RoadId, _x.curvVert, _x.u4StartDx, _x.u4Width, _x.u4ViewRangeStart, _x.u4ViewRangeEnd, _x.u4MeasuredVREnd, _x.u4C0, _x.u4C1, _x.u4C2, _x.u4C3, _x.u2LaneChange, _x.u1LaneId, _x.u1Quality, _x.u1Type, _x.u1Color, _x.u1LeftCrossing, _x.u1RightCrossing,) = _get_struct_Qd9fHb5B().unpack(str[start:end])
        self.milRoadMarks.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.initParams = []
      for i in range(0, length):
        val1 = RosAdapter.msg.init_param()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1OpenScenario = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1OpenScenario = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1OpenDrive = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1OpenDrive = str[start:end]
        _x = val1
        start = end
        end += 32
        (_x.u8StartRoadId, _x.u8EndRoadId, _x.u4StartRoadS, _x.u4EndRoadS, _x.u4Speed, _x.u2ScenarioId, _x.u1StartLaneId, _x.u1EndLaneId,) = _get_struct_2Q3fH2b().unpack(str[start:end])
        self.initParams.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.milAmesimSignals = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_amesim_signal()
        _x = val1
        start = end
        end += 57
        (_x.u4LeftLen, _x.u4NextLen, _x.u4NextAgeSpeed, _x.u4NextMinSpeed, _x.u4NextMaxSpeed, _x.u4NextGradient, _x.u4NextCongest, _x.u1RoadType, _x.u4DisLimit, _x.u1IsFarAwayLimit, _x.u4LimitSpeed, _x.ulIsJunction, _x.u4DisJunction, _x.ulIsFarAwayJunc, _x.ultrafficLightStat, _x.u4Curvity, _x.u4RelativeVel, _x.u4RelativeDis,) = _get_struct_7fBfBfBf2B3f().unpack(str[start:end])
        val1.u1IsFarAwayLimit = bool(val1.u1IsFarAwayLimit)
        val1.ulIsJunction = bool(val1.ulIsJunction)
        val1.ulIsFarAwayJunc = bool(val1.ulIsFarAwayJunc)
        self.milAmesimSignals.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.activateControllers = []
      for i in range(0, length):
        val1 = RosAdapter.msg.activate_controller()
        _x = val1
        start = end
        end += 6
        (_x.u4ObjectId, _x.u1Lateral, _x.u1Longitudinal,) = _get_struct_I2B().unpack(str[start:end])
        val1.u1Lateral = bool(val1.u1Lateral)
        val1.u1Longitudinal = bool(val1.u1Longitudinal)
        self.activateControllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.assignControllers = []
      for i in range(0, length):
        val1 = RosAdapter.msg.assign_controller()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1ControllerName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1ControllerName = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.u4ObjectId, _x.u4PropertyNum,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.properties = []
        for i in range(0, length):
          val2 = RosAdapter.msg.assign_controller_property()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.au1Name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2.au1Name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.au1Value = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2.au1Value = str[start:end]
          val1.properties.append(val2)
        self.assignControllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.overrideControllers = []
      for i in range(0, length):
        val1 = RosAdapter.msg.override_controller()
        _x = val1
        start = end
        end += 58
        (_x.u8ThrottleValue, _x.u8BrakeValue, _x.u8SteeringWheelValue, _x.u8ParkingBrakeValue, _x.u8ClutchValue, _x.u8GearValue, _x.u4ObjectId, _x.u1ThrottleActive, _x.u1BrakeActive, _x.u1SteeringWheelActive, _x.u1ParkingBrakeActive, _x.u1ClutchActive, _x.u1GearActive,) = _get_struct_6dI6B().unpack(str[start:end])
        val1.u1ThrottleActive = bool(val1.u1ThrottleActive)
        val1.u1BrakeActive = bool(val1.u1BrakeActive)
        val1.u1SteeringWheelActive = bool(val1.u1SteeringWheelActive)
        val1.u1ParkingBrakeActive = bool(val1.u1ParkingBrakeActive)
        val1.u1ClutchActive = bool(val1.u1ClutchActive)
        val1.u1GearActive = bool(val1.u1GearActive)
        self.overrideControllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.customCommands = []
      for i in range(0, length):
        val1 = RosAdapter.msg.custom_command()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Type = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Command = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Command = str[start:end]
        start = end
        end += 4
        (val1.u4ObjectId,) = _get_struct_I().unpack(str[start:end])
        self.customCommands.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.parkingSpaces = []
      for i in range(0, length):
        val1 = RosAdapter.msg.parkingSpace()
        _v57 = val1.sGeo
        _x = _v57
        start = end
        end += 24
        (_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ,) = _get_struct_6f().unpack(str[start:end])
        _v58 = val1.sPos
        _x = _v58
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _x = val1
        start = end
        end += 16
        (_x.u4RoadS, _x.u4RoadT, _x.u8SlotId,) = _get_struct_2fQ().unpack(str[start:end])
        self.parkingSpaces.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.driverCtrls = []
      for i in range(0, length):
        val1 = RosAdapter.msg.driver_ctrl()
        _x = val1
        start = end
        end += 296
        (_x.u4ObjectId, _x.u4MtWheel, _x.u8MasterCylinderPressure, _x.u8SteeringWheel, _x.u8ThrottlePedal, _x.u8BrakePedal, _x.u8AccelTgt, _x.u8SteeringTorque, _x.u8StopDistance, _x.u8TargetSpeed, _x.u8Vx, _x.u8Wr, _x.u8VLFWheelSpd, _x.u8VRFWheelSpd, _x.u8VLRWheelSpd, _x.u8VRRWheelSpd, _x.u8Ax, _x.u8Ay, _x.u8SteeringWheelAngularRate, _x.u8DrvTorqAct, _x.u8Xmc, _x.u8Ymc, _x.u8YawThetaVehicle, _x.u8PitchThetaVehicle, _x.u8RollThetaVehicle, _x.u8PitchRateVehicle, _x.u8RollRateVehicle, _x.u8SinSlopeout, _x.u8VehicleCurv, _x.u8TmotorCmd, _x.u8Tmotor, _x.u8EnergySourceLevel, _x.u8WLFWheelSpd, _x.u8WRFWheelSpd, _x.u8WLRWheelSpd, _x.u8WRRWheelSpd, _x.u8WGearSpd, _x.u1LFWheelRotatedDir, _x.u1LRWheelRotatedDir, _x.u1RFWheelRotatedDir, _x.u1RRWheelRotatedDir, _x.u1BrakePedalStatus, _x.u1VehicleDir, _x.u1BrkType, _x.u1Gear,) = _get_struct_If35d7Bb().unpack(str[start:end])
        self.driverCtrls.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.syncs = []
      for i in range(0, length):
        val1 = RosAdapter.msg.sync()
        _x = val1
        start = end
        end += 8
        (_x.u4CmdMask, _x.u4UserData,) = _get_struct_2I().unpack(str[start:end])
        self.syncs.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.imuDatas = []
      for i in range(0, length):
        val1 = RosAdapter.msg.imu_data()
        _x = val1
        start = end
        end += 49
        (_x.msgcnt, _x.u8X, _x.u8Y, _x.u8Z, _x.yaw, _x.pitch, _x.roll,) = _get_struct_B6d().unpack(str[start:end])
        self.imuDatas.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.gnssGgaS = []
      for i in range(0, length):
        val1 = RosAdapter.msg.gnss_gga()
        start = end
        end += 1
        (val1.startChar,) = _get_struct_B().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.cmd = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mTime = str[start:end]
        _x = val1
        start = end
        end += 18
        (_x.lat, _x.NorS, _x.lon, _x.EorW,) = _get_struct_dBdB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mode = str[start:end]
        _x = val1
        start = end
        end += 43
        (_x.count, _x.horizonprecious, _x.geoidalheight, _x.meter1, _x.height, _x.meter2, _x.dataage, _x.basestationflag, _x.sperator,) = _get_struct_i2dBdBdiB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.checksum = str[start:end]
        self.gnssGgaS.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.uwbDatas = []
      for i in range(0, length):
        val1 = RosAdapter.msg.uwb_data()
        _x = val1
        start = end
        end += 25
        (_x.msgcnt, _x.u8x, _x.u8y, _x.u8z,) = _get_struct_B3d().unpack(str[start:end])
        self.uwbDatas.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.modelOutlines = []
      for i in range(0, length):
        val1 = RosAdapter.msg.model_outline()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1ModelName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.au8OutlinePoints = []
        for i in range(0, length):
          val2 = RosAdapter.msg.double_array()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          val2.data = s.unpack(str[start:end])
          val1.au8OutlinePoints.append(val2)
        self.modelOutlines.append(val1)
      start = end
      end += 4
      (self.rsuVnfpInfo.type,) = _get_struct_I().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_d3I().pack(_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo))
      length = len(self.laneInfos)
      buff.write(_struct_I.pack(length))
      for val1 in self.laneInfos:
        _x = val1
        buff.write(_get_struct_QIfHbB2b().pack(_x.u8RoadId, _x.u4ObjectId, _x.u4Width, _x.u2Type, _x.u1Id, _x.u1NeighborMask, _x.u1LeftLaneId, _x.u1RightLaneId))
      length = len(self.sensorStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensorStates:
        _v59 = val1.sPos
        _x = _v59
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v60 = val1.sOriginCoordSys
        _x = _v60
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1.au1Name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u8HostId, _x.u8Id))
        length = len(val1.au4FovHV)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.au4FovHV.tostring())
        length = len(val1.au4ClipNF)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.au4ClipNF.tostring())
        length = len(val1.au4FovOffHV)
        buff.write(_struct_I.pack(length))
        pattern = '<%sf'%length
        buff.write(val1.au4FovOffHV.tostring())
        _x = val1
        buff.write(_get_struct_2Bd2I7d().pack(_x.u1Type, _x.u1ModelType, _x.u4IdealFreq, _x.u4ResL, _x.u4ResV, _x.u4SenSizeL, _x.u4SenSizeW, _x.u4LenFd, _x.u4DistCenL, _x.u4DistCenW, _x.u4DistParK1, _x.u4DistParK2))
      length = len(self.sensorObjects)
      buff.write(_struct_I.pack(length))
      for val1 in self.sensorObjects:
        _x = val1
        buff.write(_get_struct_2IHB2bB2d().pack(_x.u4Id, _x.u4SensorId, _x.u2Flags, _x.u1Type, _x.u1Occlusion, _x.u1DeltaLanePos, _x.u1ValidFlag, _x.u8ExistProb, _x.u8TypeIdProb))
        _v61 = val1.sExtraInfo
        _v62 = _v61.sDynamicObj
        _x = _v62
        buff.write(_get_struct_7d().pack(_x.u8Dist, _x.u8NearestDist, _x.u8RelativeVelx, _x.u8RelativeVely, _x.u8RelativeAccx, _x.u8RelativeAccy, _x.u8HeadingAngle))
        _v63 = _v62.sSensorPos
        _x = _v63
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v64 = _v62.sNearestSensorPos
        _x = _v64
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v65 = _v62.sSenNearestPosXL
        _x = _v65
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v66 = _v62.sSenNearestPosXR
        _x = _v66
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v67 = _v62.sSenNearestPosYL
        _x = _v67
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v68 = _v62.sSenNearestPosYR
        _x = _v68
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        length = len(_v62.sBoundingBox)
        buff.write(_struct_I.pack(length))
        for val4 in _v62.sBoundingBox:
          _x = val4
          buff.write(_get_struct_3d().pack(_x.u8x, _x.u8y, _x.u8z))
        _x = _v62.u1MovingSt
        buff.write(_get_struct_B().pack(_x))
        _v69 = _v61.sMarkObj
        length = len(_v69.au8RoadMarkCoeffL)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v69.au8RoadMarkCoeffL.tostring())
        length = len(_v69.au8RoadMarkCoeffR)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v69.au8RoadMarkCoeffR.tostring())
        _v70 = _v61.sSignObj
        _x = _v70
        buff.write(_get_struct_4d().pack(_x.u8Dist, _x.u8NearestDist, _x.u8TrafficSignDistX, _x.u8TrafficSignDistY))
        _v71 = _v70.sSensorPos
        _x = _v71
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v72 = _v70.sNearestSensorPos
        _x = _v72
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = _v70.u1TrafficSignType
        buff.write(_get_struct_B().pack(_x))
      length = len(self.contactPoints)
      buff.write(_struct_I.pack(length))
      for val1 in self.contactPoints:
        _v73 = val1.sRoadDataIn
        _x = _v73
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1.u2Id
        buff.write(_get_struct_H().pack(_x))
      length = len(self.trafficSigns)
      buff.write(_struct_I.pack(length))
      for val1 in self.trafficSigns:
        _x = val1.au1Type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _v74 = val1.sPos
        _x = _v74
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u4TrafficSignId, _x.u4ObjectId))
        _x = val1.au1SubType
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2f2b().pack(_x.u4RoadDist, _x.u4Value, _x.u1MinLane, _x.u1MaxLane))
      length = len(self.roadStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.roadStates:
        _x = val1
        buff.write(_get_struct_QI3f().pack(_x.u8RoadId, _x.u4ObjectId, _x.u4DefaultSpeed, _x.u4WaterLevel, _x.u4DistToJunc))
      length = len(self.environments)
      buff.write(_struct_I.pack(length))
      for val1 in self.environments:
        _x = val1
        buff.write(_get_struct_4dIhH3B().pack(_x.u8RainIntensity, _x.u8SnowIntensity, _x.u8FogIntensity, _x.u8FogVisualRange, _x.u4TimeOfDay, _x.u2TimeZoneMinutesWest, _x.u2Year, _x.u1CloudState, _x.u1Day, _x.u1Month))
      length = len(self.trafficLights)
      buff.write(_struct_I.pack(length))
      for val1 in self.trafficLights:
        _x = val1
        buff.write(_get_struct_2i2I2f().pack(_x.u4Id, _x.u4CtrlId, _x.u4NoPhases, _x.u4DataSize, _x.u4State, _x.u4CycleTime))
        length = len(val1.phases)
        buff.write(_struct_I.pack(length))
        for val2 in val1.phases:
          _x = val2
          buff.write(_get_struct_fB().pack(_x.u4Duration, _x.u1Status))
      length = len(self.roadQueries)
      buff.write(_struct_I.pack(length))
      for val1 in self.roadQueries:
        _x = val1
        buff.write(_get_struct_2fH().pack(_x.u8X, _x.u8Y, _x.u2Id))
      length = len(self.egoStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.egoStates:
        _v75 = val1.sObjectState
        _v76 = _v75.sSpeed
        _x = _v76
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v77 = _v75.sAccel
        _x = _v77
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v78 = _v75.sGeo
        _x = _v78
        buff.write(_get_struct_6f().pack(_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ))
        _v79 = _v75.sPos
        _x = _v79
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = _v75.au1Name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v75.au1ModelFileName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v75.au1ModelName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(_v75.au8ParamScale)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v75.au8ParamScale.tostring())
        _x = _v75
        buff.write(_get_struct_QdI5fHBb3B().pack(_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category))
        _x = val1
        buff.write(_get_struct_2dI10f8B().pack(_x.u4initSpeed, _x.u8DistRoadEnd, _x.u4LightMask, _x.u4WheelSpeedFL, _x.u4WheelSpeedFR, _x.u4WheelSpeedRL, _x.u4WheelSpeedRR, _x.u4MasterCylinderPressure, _x.u4WheelHeightLF, _x.u4WheelHeightLR, _x.u4WheelHeightRF, _x.u4WheelHeightRR, _x.u4SteerAngle, _x.u1objQuantity, _x.u1irc_id, _x.u1irc_left_id, _x.u1irc_right_id, _x.u1cipv_id, _x.u1lmc_id, _x.u1rmc_id, _x.u1isReachInitSpeed))
      length = len(self.milObjStates)
      buff.write(_struct_I.pack(length))
      for val1 in self.milObjStates:
        _v80 = val1.sObjectState
        _v81 = _v80.sSpeed
        _x = _v81
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v82 = _v80.sAccel
        _x = _v82
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _v83 = _v80.sGeo
        _x = _v83
        buff.write(_get_struct_6f().pack(_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ))
        _v84 = _v80.sPos
        _x = _v84
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = _v80.au1Name
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v80.au1ModelFileName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = _v80.au1ModelName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(_v80.au8ParamScale)
        buff.write(_struct_I.pack(length))
        pattern = '<%sd'%length
        buff.write(_v80.au8ParamScale.tostring())
        _x = _v80
        buff.write(_get_struct_QdI5fHBb3B().pack(_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category))
        _v85 = val1.sMilBase
        _x = _v85
        buff.write(_get_struct_I9f5B().pack(_x.u4LightMask, _x.u4DistanceX, _x.u4DistanceY, _x.u4VelocityX, _x.u4VelocityY, _x.u4AccelerationX, _x.u4AccelerationY, _x.u4YawRate, _x.u4Dist, _x.u4Angle, _x.u1ObjClass, _x.u1Flag_detected, _x.u1Movable, _x.u1Moving, _x.u1Obj_Age))
      length = len(self.milRoadMarks)
      buff.write(_struct_I.pack(length))
      for val1 in self.milRoadMarks:
        _x = val1
        buff.write(_get_struct_Qd9fHb5B().pack(_x.u8RoadId, _x.curvVert, _x.u4StartDx, _x.u4Width, _x.u4ViewRangeStart, _x.u4ViewRangeEnd, _x.u4MeasuredVREnd, _x.u4C0, _x.u4C1, _x.u4C2, _x.u4C3, _x.u2LaneChange, _x.u1LaneId, _x.u1Quality, _x.u1Type, _x.u1Color, _x.u1LeftCrossing, _x.u1RightCrossing))
      length = len(self.initParams)
      buff.write(_struct_I.pack(length))
      for val1 in self.initParams:
        _x = val1.au1OpenScenario
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.au1OpenDrive
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2Q3fH2b().pack(_x.u8StartRoadId, _x.u8EndRoadId, _x.u4StartRoadS, _x.u4EndRoadS, _x.u4Speed, _x.u2ScenarioId, _x.u1StartLaneId, _x.u1EndLaneId))
      length = len(self.milAmesimSignals)
      buff.write(_struct_I.pack(length))
      for val1 in self.milAmesimSignals:
        _x = val1
        buff.write(_get_struct_7fBfBfBf2B3f().pack(_x.u4LeftLen, _x.u4NextLen, _x.u4NextAgeSpeed, _x.u4NextMinSpeed, _x.u4NextMaxSpeed, _x.u4NextGradient, _x.u4NextCongest, _x.u1RoadType, _x.u4DisLimit, _x.u1IsFarAwayLimit, _x.u4LimitSpeed, _x.ulIsJunction, _x.u4DisJunction, _x.ulIsFarAwayJunc, _x.ultrafficLightStat, _x.u4Curvity, _x.u4RelativeVel, _x.u4RelativeDis))
      length = len(self.activateControllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.activateControllers:
        _x = val1
        buff.write(_get_struct_I2B().pack(_x.u4ObjectId, _x.u1Lateral, _x.u1Longitudinal))
      length = len(self.assignControllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.assignControllers:
        _x = val1.au1ControllerName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u4ObjectId, _x.u4PropertyNum))
        length = len(val1.properties)
        buff.write(_struct_I.pack(length))
        for val2 in val1.properties:
          _x = val2.au1Name
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
          _x = val2.au1Value
          length = len(_x)
          if python3 or type(_x) == unicode:
            _x = _x.encode('utf-8')
            length = len(_x)
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.overrideControllers)
      buff.write(_struct_I.pack(length))
      for val1 in self.overrideControllers:
        _x = val1
        buff.write(_get_struct_6dI6B().pack(_x.u8ThrottleValue, _x.u8BrakeValue, _x.u8SteeringWheelValue, _x.u8ParkingBrakeValue, _x.u8ClutchValue, _x.u8GearValue, _x.u4ObjectId, _x.u1ThrottleActive, _x.u1BrakeActive, _x.u1SteeringWheelActive, _x.u1ParkingBrakeActive, _x.u1ClutchActive, _x.u1GearActive))
      length = len(self.customCommands)
      buff.write(_struct_I.pack(length))
      for val1 in self.customCommands:
        _x = val1.au1Type
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.au1Command
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.u4ObjectId
        buff.write(_get_struct_I().pack(_x))
      length = len(self.parkingSpaces)
      buff.write(_struct_I.pack(length))
      for val1 in self.parkingSpaces:
        _v86 = val1.sGeo
        _x = _v86
        buff.write(_get_struct_6f().pack(_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ))
        _v87 = val1.sPos
        _x = _v87
        buff.write(_get_struct_3d3fB().pack(_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type))
        _x = val1
        buff.write(_get_struct_2fQ().pack(_x.u4RoadS, _x.u4RoadT, _x.u8SlotId))
      length = len(self.driverCtrls)
      buff.write(_struct_I.pack(length))
      for val1 in self.driverCtrls:
        _x = val1
        buff.write(_get_struct_If35d7Bb().pack(_x.u4ObjectId, _x.u4MtWheel, _x.u8MasterCylinderPressure, _x.u8SteeringWheel, _x.u8ThrottlePedal, _x.u8BrakePedal, _x.u8AccelTgt, _x.u8SteeringTorque, _x.u8StopDistance, _x.u8TargetSpeed, _x.u8Vx, _x.u8Wr, _x.u8VLFWheelSpd, _x.u8VRFWheelSpd, _x.u8VLRWheelSpd, _x.u8VRRWheelSpd, _x.u8Ax, _x.u8Ay, _x.u8SteeringWheelAngularRate, _x.u8DrvTorqAct, _x.u8Xmc, _x.u8Ymc, _x.u8YawThetaVehicle, _x.u8PitchThetaVehicle, _x.u8RollThetaVehicle, _x.u8PitchRateVehicle, _x.u8RollRateVehicle, _x.u8SinSlopeout, _x.u8VehicleCurv, _x.u8TmotorCmd, _x.u8Tmotor, _x.u8EnergySourceLevel, _x.u8WLFWheelSpd, _x.u8WRFWheelSpd, _x.u8WLRWheelSpd, _x.u8WRRWheelSpd, _x.u8WGearSpd, _x.u1LFWheelRotatedDir, _x.u1LRWheelRotatedDir, _x.u1RFWheelRotatedDir, _x.u1RRWheelRotatedDir, _x.u1BrakePedalStatus, _x.u1VehicleDir, _x.u1BrkType, _x.u1Gear))
      length = len(self.syncs)
      buff.write(_struct_I.pack(length))
      for val1 in self.syncs:
        _x = val1
        buff.write(_get_struct_2I().pack(_x.u4CmdMask, _x.u4UserData))
      length = len(self.imuDatas)
      buff.write(_struct_I.pack(length))
      for val1 in self.imuDatas:
        _x = val1
        buff.write(_get_struct_B6d().pack(_x.msgcnt, _x.u8X, _x.u8Y, _x.u8Z, _x.yaw, _x.pitch, _x.roll))
      length = len(self.gnssGgaS)
      buff.write(_struct_I.pack(length))
      for val1 in self.gnssGgaS:
        _x = val1.startChar
        buff.write(_get_struct_B().pack(_x))
        _x = val1.cmd
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1.mTime
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_dBdB().pack(_x.lat, _x.NorS, _x.lon, _x.EorW))
        _x = val1.mode
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_i2dBdBdiB().pack(_x.count, _x.horizonprecious, _x.geoidalheight, _x.meter1, _x.height, _x.meter2, _x.dataage, _x.basestationflag, _x.sperator))
        _x = val1.checksum
        length = len(_x)
        # - if encoded as a list instead, serialize as bytes instead of string
        if type(_x) in [list, tuple]:
          buff.write(struct.Struct('<I%sB'%length).pack(length, *_x))
        else:
          buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.uwbDatas)
      buff.write(_struct_I.pack(length))
      for val1 in self.uwbDatas:
        _x = val1
        buff.write(_get_struct_B3d().pack(_x.msgcnt, _x.u8x, _x.u8y, _x.u8z))
      length = len(self.modelOutlines)
      buff.write(_struct_I.pack(length))
      for val1 in self.modelOutlines:
        _x = val1.au1ModelName
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.au8OutlinePoints)
        buff.write(_struct_I.pack(length))
        for val2 in val1.au8OutlinePoints:
          length = len(val2.data)
          buff.write(_struct_I.pack(length))
          pattern = '<%sd'%length
          buff.write(val2.data.tostring())
      _x = self.rsuVnfpInfo.type
      buff.write(_get_struct_I().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.laneInfos is None:
        self.laneInfos = None
      if self.sensorStates is None:
        self.sensorStates = None
      if self.sensorObjects is None:
        self.sensorObjects = None
      if self.contactPoints is None:
        self.contactPoints = None
      if self.trafficSigns is None:
        self.trafficSigns = None
      if self.roadStates is None:
        self.roadStates = None
      if self.environments is None:
        self.environments = None
      if self.trafficLights is None:
        self.trafficLights = None
      if self.roadQueries is None:
        self.roadQueries = None
      if self.egoStates is None:
        self.egoStates = None
      if self.milObjStates is None:
        self.milObjStates = None
      if self.milRoadMarks is None:
        self.milRoadMarks = None
      if self.initParams is None:
        self.initParams = None
      if self.milAmesimSignals is None:
        self.milAmesimSignals = None
      if self.activateControllers is None:
        self.activateControllers = None
      if self.assignControllers is None:
        self.assignControllers = None
      if self.overrideControllers is None:
        self.overrideControllers = None
      if self.customCommands is None:
        self.customCommands = None
      if self.parkingSpaces is None:
        self.parkingSpaces = None
      if self.driverCtrls is None:
        self.driverCtrls = None
      if self.syncs is None:
        self.syncs = None
      if self.imuDatas is None:
        self.imuDatas = None
      if self.gnssGgaS is None:
        self.gnssGgaS = None
      if self.uwbDatas is None:
        self.uwbDatas = None
      if self.modelOutlines is None:
        self.modelOutlines = None
      if self.rsuVnfpInfo is None:
        self.rsuVnfpInfo = RosAdapter.msg.rsu_vnfp_info()
      end = 0
      _x = self
      start = end
      end += 20
      (_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo,) = _get_struct_d3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.laneInfos = []
      for i in range(0, length):
        val1 = RosAdapter.msg.lane_info()
        _x = val1
        start = end
        end += 22
        (_x.u8RoadId, _x.u4ObjectId, _x.u4Width, _x.u2Type, _x.u1Id, _x.u1NeighborMask, _x.u1LeftLaneId, _x.u1RightLaneId,) = _get_struct_QIfHbB2b().unpack(str[start:end])
        self.laneInfos.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensorStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.sensor_info()
        _v88 = val1.sPos
        _x = _v88
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v89 = val1.sOriginCoordSys
        _x = _v89
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Name = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.u8HostId, _x.u8Id,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.au4FovHV = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.au4ClipNF = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sf'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.au4FovOffHV = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
        _x = val1
        start = end
        end += 74
        (_x.u1Type, _x.u1ModelType, _x.u4IdealFreq, _x.u4ResL, _x.u4ResV, _x.u4SenSizeL, _x.u4SenSizeW, _x.u4LenFd, _x.u4DistCenL, _x.u4DistCenW, _x.u4DistParK1, _x.u4DistParK2,) = _get_struct_2Bd2I7d().unpack(str[start:end])
        self.sensorStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.sensorObjects = []
      for i in range(0, length):
        val1 = RosAdapter.msg.sensor_detection_info()
        _x = val1
        start = end
        end += 30
        (_x.u4Id, _x.u4SensorId, _x.u2Flags, _x.u1Type, _x.u1Occlusion, _x.u1DeltaLanePos, _x.u1ValidFlag, _x.u8ExistProb, _x.u8TypeIdProb,) = _get_struct_2IHB2bB2d().unpack(str[start:end])
        _v90 = val1.sExtraInfo
        _v91 = _v90.sDynamicObj
        _x = _v91
        start = end
        end += 56
        (_x.u8Dist, _x.u8NearestDist, _x.u8RelativeVelx, _x.u8RelativeVely, _x.u8RelativeAccx, _x.u8RelativeAccy, _x.u8HeadingAngle,) = _get_struct_7d().unpack(str[start:end])
        _v92 = _v91.sSensorPos
        _x = _v92
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v93 = _v91.sNearestSensorPos
        _x = _v93
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v94 = _v91.sSenNearestPosXL
        _x = _v94
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v95 = _v91.sSenNearestPosXR
        _x = _v95
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v96 = _v91.sSenNearestPosYL
        _x = _v96
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v97 = _v91.sSenNearestPosYR
        _x = _v97
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        _v91.sBoundingBox = []
        for i in range(0, length):
          val4 = RosAdapter.msg.point3d()
          _x = val4
          start = end
          end += 24
          (_x.u8x, _x.u8y, _x.u8z,) = _get_struct_3d().unpack(str[start:end])
          _v91.sBoundingBox.append(val4)
        start = end
        end += 1
        (_v91.u1MovingSt,) = _get_struct_B().unpack(str[start:end])
        _v98 = _v90.sMarkObj
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v98.au8RoadMarkCoeffL = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v98.au8RoadMarkCoeffR = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _v99 = _v90.sSignObj
        _x = _v99
        start = end
        end += 32
        (_x.u8Dist, _x.u8NearestDist, _x.u8TrafficSignDistX, _x.u8TrafficSignDistY,) = _get_struct_4d().unpack(str[start:end])
        _v100 = _v99.sSensorPos
        _x = _v100
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v101 = _v99.sNearestSensorPos
        _x = _v101
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 1
        (_v99.u1TrafficSignType,) = _get_struct_B().unpack(str[start:end])
        self.sensorObjects.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.contactPoints = []
      for i in range(0, length):
        val1 = RosAdapter.msg.contact_point()
        _v102 = val1.sRoadDataIn
        _x = _v102
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 2
        (val1.u2Id,) = _get_struct_H().unpack(str[start:end])
        self.contactPoints.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trafficSigns = []
      for i in range(0, length):
        val1 = RosAdapter.msg.traffic_sign()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Type = str[start:end]
        _v103 = val1.sPos
        _x = _v103
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _x = val1
        start = end
        end += 8
        (_x.u4TrafficSignId, _x.u4ObjectId,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1SubType = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1SubType = str[start:end]
        _x = val1
        start = end
        end += 10
        (_x.u4RoadDist, _x.u4Value, _x.u1MinLane, _x.u1MaxLane,) = _get_struct_2f2b().unpack(str[start:end])
        self.trafficSigns.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.roadStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.road_state()
        _x = val1
        start = end
        end += 24
        (_x.u8RoadId, _x.u4ObjectId, _x.u4DefaultSpeed, _x.u4WaterLevel, _x.u4DistToJunc,) = _get_struct_QI3f().unpack(str[start:end])
        self.roadStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.environments = []
      for i in range(0, length):
        val1 = RosAdapter.msg.environment()
        _x = val1
        start = end
        end += 43
        (_x.u8RainIntensity, _x.u8SnowIntensity, _x.u8FogIntensity, _x.u8FogVisualRange, _x.u4TimeOfDay, _x.u2TimeZoneMinutesWest, _x.u2Year, _x.u1CloudState, _x.u1Day, _x.u1Month,) = _get_struct_4dIhH3B().unpack(str[start:end])
        self.environments.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.trafficLights = []
      for i in range(0, length):
        val1 = RosAdapter.msg.traffic_light()
        _x = val1
        start = end
        end += 24
        (_x.u4Id, _x.u4CtrlId, _x.u4NoPhases, _x.u4DataSize, _x.u4State, _x.u4CycleTime,) = _get_struct_2i2I2f().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.phases = []
        for i in range(0, length):
          val2 = RosAdapter.msg.traffic_light_phase()
          _x = val2
          start = end
          end += 5
          (_x.u4Duration, _x.u1Status,) = _get_struct_fB().unpack(str[start:end])
          val1.phases.append(val2)
        self.trafficLights.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.roadQueries = []
      for i in range(0, length):
        val1 = RosAdapter.msg.road_query()
        _x = val1
        start = end
        end += 10
        (_x.u8X, _x.u8Y, _x.u2Id,) = _get_struct_2fH().unpack(str[start:end])
        self.roadQueries.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.egoStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_ego_state()
        _v104 = val1.sObjectState
        _v105 = _v104.sSpeed
        _x = _v105
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v106 = _v104.sAccel
        _x = _v106
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v107 = _v104.sGeo
        _x = _v107
        start = end
        end += 24
        (_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ,) = _get_struct_6f().unpack(str[start:end])
        _v108 = _v104.sPos
        _x = _v108
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v104.au1Name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v104.au1Name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v104.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v104.au1ModelFileName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v104.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v104.au1ModelName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v104.au8ParamScale = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = _v104
        start = end
        end += 47
        (_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category,) = _get_struct_QdI5fHBb3B().unpack(str[start:end])
        _v104.u1IsOnRoad = bool(_v104.u1IsOnRoad)
        _x = val1
        start = end
        end += 68
        (_x.u4initSpeed, _x.u8DistRoadEnd, _x.u4LightMask, _x.u4WheelSpeedFL, _x.u4WheelSpeedFR, _x.u4WheelSpeedRL, _x.u4WheelSpeedRR, _x.u4MasterCylinderPressure, _x.u4WheelHeightLF, _x.u4WheelHeightLR, _x.u4WheelHeightRF, _x.u4WheelHeightRR, _x.u4SteerAngle, _x.u1objQuantity, _x.u1irc_id, _x.u1irc_left_id, _x.u1irc_right_id, _x.u1cipv_id, _x.u1lmc_id, _x.u1rmc_id, _x.u1isReachInitSpeed,) = _get_struct_2dI10f8B().unpack(str[start:end])
        self.egoStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.milObjStates = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_object_state()
        _v109 = val1.sObjectState
        _v110 = _v109.sSpeed
        _x = _v110
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v111 = _v109.sAccel
        _x = _v111
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _v112 = _v109.sGeo
        _x = _v112
        start = end
        end += 24
        (_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ,) = _get_struct_6f().unpack(str[start:end])
        _v113 = _v109.sPos
        _x = _v113
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v109.au1Name = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v109.au1Name = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v109.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v109.au1ModelFileName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          _v109.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          _v109.au1ModelName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sd'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        _v109.au8ParamScale = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
        _x = _v109
        start = end
        end += 47
        (_x.u8RoadId, _x.u8SpeedLimit, _x.u4Id, _x.u4RoadS, _x.u4RoadT, _x.u4HdgRel, _x.u4LaneOffset, _x.u4TraveledDist, _x.u2visMask, _x.u1Type, _x.u1LaneId, _x.u1Dir, _x.u1IsOnRoad, _x.u1category,) = _get_struct_QdI5fHBb3B().unpack(str[start:end])
        _v109.u1IsOnRoad = bool(_v109.u1IsOnRoad)
        _v114 = val1.sMilBase
        _x = _v114
        start = end
        end += 45
        (_x.u4LightMask, _x.u4DistanceX, _x.u4DistanceY, _x.u4VelocityX, _x.u4VelocityY, _x.u4AccelerationX, _x.u4AccelerationY, _x.u4YawRate, _x.u4Dist, _x.u4Angle, _x.u1ObjClass, _x.u1Flag_detected, _x.u1Movable, _x.u1Moving, _x.u1Obj_Age,) = _get_struct_I9f5B().unpack(str[start:end])
        self.milObjStates.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.milRoadMarks = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_roadmark()
        _x = val1
        start = end
        end += 60
        (_x.u8RoadId, _x.curvVert, _x.u4StartDx, _x.u4Width, _x.u4ViewRangeStart, _x.u4ViewRangeEnd, _x.u4MeasuredVREnd, _x.u4C0, _x.u4C1, _x.u4C2, _x.u4C3, _x.u2LaneChange, _x.u1LaneId, _x.u1Quality, _x.u1Type, _x.u1Color, _x.u1LeftCrossing, _x.u1RightCrossing,) = _get_struct_Qd9fHb5B().unpack(str[start:end])
        self.milRoadMarks.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.initParams = []
      for i in range(0, length):
        val1 = RosAdapter.msg.init_param()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1OpenScenario = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1OpenScenario = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1OpenDrive = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1OpenDrive = str[start:end]
        _x = val1
        start = end
        end += 32
        (_x.u8StartRoadId, _x.u8EndRoadId, _x.u4StartRoadS, _x.u4EndRoadS, _x.u4Speed, _x.u2ScenarioId, _x.u1StartLaneId, _x.u1EndLaneId,) = _get_struct_2Q3fH2b().unpack(str[start:end])
        self.initParams.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.milAmesimSignals = []
      for i in range(0, length):
        val1 = RosAdapter.msg.mil_amesim_signal()
        _x = val1
        start = end
        end += 57
        (_x.u4LeftLen, _x.u4NextLen, _x.u4NextAgeSpeed, _x.u4NextMinSpeed, _x.u4NextMaxSpeed, _x.u4NextGradient, _x.u4NextCongest, _x.u1RoadType, _x.u4DisLimit, _x.u1IsFarAwayLimit, _x.u4LimitSpeed, _x.ulIsJunction, _x.u4DisJunction, _x.ulIsFarAwayJunc, _x.ultrafficLightStat, _x.u4Curvity, _x.u4RelativeVel, _x.u4RelativeDis,) = _get_struct_7fBfBfBf2B3f().unpack(str[start:end])
        val1.u1IsFarAwayLimit = bool(val1.u1IsFarAwayLimit)
        val1.ulIsJunction = bool(val1.ulIsJunction)
        val1.ulIsFarAwayJunc = bool(val1.ulIsFarAwayJunc)
        self.milAmesimSignals.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.activateControllers = []
      for i in range(0, length):
        val1 = RosAdapter.msg.activate_controller()
        _x = val1
        start = end
        end += 6
        (_x.u4ObjectId, _x.u1Lateral, _x.u1Longitudinal,) = _get_struct_I2B().unpack(str[start:end])
        val1.u1Lateral = bool(val1.u1Lateral)
        val1.u1Longitudinal = bool(val1.u1Longitudinal)
        self.activateControllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.assignControllers = []
      for i in range(0, length):
        val1 = RosAdapter.msg.assign_controller()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1ControllerName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1ControllerName = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.u4ObjectId, _x.u4PropertyNum,) = _get_struct_2I().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.properties = []
        for i in range(0, length):
          val2 = RosAdapter.msg.assign_controller_property()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.au1Name = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2.au1Name = str[start:end]
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          start = end
          end += length
          if python3:
            val2.au1Value = str[start:end].decode('utf-8', 'rosmsg')
          else:
            val2.au1Value = str[start:end]
          val1.properties.append(val2)
        self.assignControllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.overrideControllers = []
      for i in range(0, length):
        val1 = RosAdapter.msg.override_controller()
        _x = val1
        start = end
        end += 58
        (_x.u8ThrottleValue, _x.u8BrakeValue, _x.u8SteeringWheelValue, _x.u8ParkingBrakeValue, _x.u8ClutchValue, _x.u8GearValue, _x.u4ObjectId, _x.u1ThrottleActive, _x.u1BrakeActive, _x.u1SteeringWheelActive, _x.u1ParkingBrakeActive, _x.u1ClutchActive, _x.u1GearActive,) = _get_struct_6dI6B().unpack(str[start:end])
        val1.u1ThrottleActive = bool(val1.u1ThrottleActive)
        val1.u1BrakeActive = bool(val1.u1BrakeActive)
        val1.u1SteeringWheelActive = bool(val1.u1SteeringWheelActive)
        val1.u1ParkingBrakeActive = bool(val1.u1ParkingBrakeActive)
        val1.u1ClutchActive = bool(val1.u1ClutchActive)
        val1.u1GearActive = bool(val1.u1GearActive)
        self.overrideControllers.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.customCommands = []
      for i in range(0, length):
        val1 = RosAdapter.msg.custom_command()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Type = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Type = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1Command = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1Command = str[start:end]
        start = end
        end += 4
        (val1.u4ObjectId,) = _get_struct_I().unpack(str[start:end])
        self.customCommands.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.parkingSpaces = []
      for i in range(0, length):
        val1 = RosAdapter.msg.parkingSpace()
        _v115 = val1.sGeo
        _x = _v115
        start = end
        end += 24
        (_x.u4DimX, _x.u4DimY, _x.u4DimZ, _x.u4OffX, _x.u4OffY, _x.u4OffZ,) = _get_struct_6f().unpack(str[start:end])
        _v116 = val1.sPos
        _x = _v116
        start = end
        end += 37
        (_x.u8X, _x.u8Y, _x.u8Z, _x.u4H, _x.u4P, _x.u4R, _x.u1Type,) = _get_struct_3d3fB().unpack(str[start:end])
        _x = val1
        start = end
        end += 16
        (_x.u4RoadS, _x.u4RoadT, _x.u8SlotId,) = _get_struct_2fQ().unpack(str[start:end])
        self.parkingSpaces.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.driverCtrls = []
      for i in range(0, length):
        val1 = RosAdapter.msg.driver_ctrl()
        _x = val1
        start = end
        end += 296
        (_x.u4ObjectId, _x.u4MtWheel, _x.u8MasterCylinderPressure, _x.u8SteeringWheel, _x.u8ThrottlePedal, _x.u8BrakePedal, _x.u8AccelTgt, _x.u8SteeringTorque, _x.u8StopDistance, _x.u8TargetSpeed, _x.u8Vx, _x.u8Wr, _x.u8VLFWheelSpd, _x.u8VRFWheelSpd, _x.u8VLRWheelSpd, _x.u8VRRWheelSpd, _x.u8Ax, _x.u8Ay, _x.u8SteeringWheelAngularRate, _x.u8DrvTorqAct, _x.u8Xmc, _x.u8Ymc, _x.u8YawThetaVehicle, _x.u8PitchThetaVehicle, _x.u8RollThetaVehicle, _x.u8PitchRateVehicle, _x.u8RollRateVehicle, _x.u8SinSlopeout, _x.u8VehicleCurv, _x.u8TmotorCmd, _x.u8Tmotor, _x.u8EnergySourceLevel, _x.u8WLFWheelSpd, _x.u8WRFWheelSpd, _x.u8WLRWheelSpd, _x.u8WRRWheelSpd, _x.u8WGearSpd, _x.u1LFWheelRotatedDir, _x.u1LRWheelRotatedDir, _x.u1RFWheelRotatedDir, _x.u1RRWheelRotatedDir, _x.u1BrakePedalStatus, _x.u1VehicleDir, _x.u1BrkType, _x.u1Gear,) = _get_struct_If35d7Bb().unpack(str[start:end])
        self.driverCtrls.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.syncs = []
      for i in range(0, length):
        val1 = RosAdapter.msg.sync()
        _x = val1
        start = end
        end += 8
        (_x.u4CmdMask, _x.u4UserData,) = _get_struct_2I().unpack(str[start:end])
        self.syncs.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.imuDatas = []
      for i in range(0, length):
        val1 = RosAdapter.msg.imu_data()
        _x = val1
        start = end
        end += 49
        (_x.msgcnt, _x.u8X, _x.u8Y, _x.u8Z, _x.yaw, _x.pitch, _x.roll,) = _get_struct_B6d().unpack(str[start:end])
        self.imuDatas.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.gnssGgaS = []
      for i in range(0, length):
        val1 = RosAdapter.msg.gnss_gga()
        start = end
        end += 1
        (val1.startChar,) = _get_struct_B().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.cmd = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mTime = str[start:end]
        _x = val1
        start = end
        end += 18
        (_x.lat, _x.NorS, _x.lon, _x.EorW,) = _get_struct_dBdB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.mode = str[start:end]
        _x = val1
        start = end
        end += 43
        (_x.count, _x.horizonprecious, _x.geoidalheight, _x.meter1, _x.height, _x.meter2, _x.dataage, _x.basestationflag, _x.sperator,) = _get_struct_i2dBdBdiB().unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.checksum = str[start:end]
        self.gnssGgaS.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.uwbDatas = []
      for i in range(0, length):
        val1 = RosAdapter.msg.uwb_data()
        _x = val1
        start = end
        end += 25
        (_x.msgcnt, _x.u8x, _x.u8y, _x.u8z,) = _get_struct_B3d().unpack(str[start:end])
        self.uwbDatas.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.modelOutlines = []
      for i in range(0, length):
        val1 = RosAdapter.msg.model_outline()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.au1ModelName = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        val1.au8OutlinePoints = []
        for i in range(0, length):
          val2 = RosAdapter.msg.double_array()
          start = end
          end += 4
          (length,) = _struct_I.unpack(str[start:end])
          pattern = '<%sd'%length
          start = end
          s = struct.Struct(pattern)
          end += s.size
          val2.data = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
          val1.au8OutlinePoints.append(val2)
        self.modelOutlines.append(val1)
      start = end
      end += 4
      (self.rsuVnfpInfo.type,) = _get_struct_I().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2Bd2I7d = None
def _get_struct_2Bd2I7d():
    global _struct_2Bd2I7d
    if _struct_2Bd2I7d is None:
        _struct_2Bd2I7d = struct.Struct("<2Bd2I7d")
    return _struct_2Bd2I7d
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_2IHB2bB2d = None
def _get_struct_2IHB2bB2d():
    global _struct_2IHB2bB2d
    if _struct_2IHB2bB2d is None:
        _struct_2IHB2bB2d = struct.Struct("<2IHB2bB2d")
    return _struct_2IHB2bB2d
_struct_2Q3fH2b = None
def _get_struct_2Q3fH2b():
    global _struct_2Q3fH2b
    if _struct_2Q3fH2b is None:
        _struct_2Q3fH2b = struct.Struct("<2Q3fH2b")
    return _struct_2Q3fH2b
_struct_2dI10f8B = None
def _get_struct_2dI10f8B():
    global _struct_2dI10f8B
    if _struct_2dI10f8B is None:
        _struct_2dI10f8B = struct.Struct("<2dI10f8B")
    return _struct_2dI10f8B
_struct_2f2b = None
def _get_struct_2f2b():
    global _struct_2f2b
    if _struct_2f2b is None:
        _struct_2f2b = struct.Struct("<2f2b")
    return _struct_2f2b
_struct_2fH = None
def _get_struct_2fH():
    global _struct_2fH
    if _struct_2fH is None:
        _struct_2fH = struct.Struct("<2fH")
    return _struct_2fH
_struct_2fQ = None
def _get_struct_2fQ():
    global _struct_2fQ
    if _struct_2fQ is None:
        _struct_2fQ = struct.Struct("<2fQ")
    return _struct_2fQ
_struct_2i2I2f = None
def _get_struct_2i2I2f():
    global _struct_2i2I2f
    if _struct_2i2I2f is None:
        _struct_2i2I2f = struct.Struct("<2i2I2f")
    return _struct_2i2I2f
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
_struct_3d3fB = None
def _get_struct_3d3fB():
    global _struct_3d3fB
    if _struct_3d3fB is None:
        _struct_3d3fB = struct.Struct("<3d3fB")
    return _struct_3d3fB
_struct_4d = None
def _get_struct_4d():
    global _struct_4d
    if _struct_4d is None:
        _struct_4d = struct.Struct("<4d")
    return _struct_4d
_struct_4dIhH3B = None
def _get_struct_4dIhH3B():
    global _struct_4dIhH3B
    if _struct_4dIhH3B is None:
        _struct_4dIhH3B = struct.Struct("<4dIhH3B")
    return _struct_4dIhH3B
_struct_6dI6B = None
def _get_struct_6dI6B():
    global _struct_6dI6B
    if _struct_6dI6B is None:
        _struct_6dI6B = struct.Struct("<6dI6B")
    return _struct_6dI6B
_struct_6f = None
def _get_struct_6f():
    global _struct_6f
    if _struct_6f is None:
        _struct_6f = struct.Struct("<6f")
    return _struct_6f
_struct_7d = None
def _get_struct_7d():
    global _struct_7d
    if _struct_7d is None:
        _struct_7d = struct.Struct("<7d")
    return _struct_7d
_struct_7fBfBfBf2B3f = None
def _get_struct_7fBfBfBf2B3f():
    global _struct_7fBfBfBf2B3f
    if _struct_7fBfBfBf2B3f is None:
        _struct_7fBfBfBf2B3f = struct.Struct("<7fBfBfBf2B3f")
    return _struct_7fBfBfBf2B3f
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_B3d = None
def _get_struct_B3d():
    global _struct_B3d
    if _struct_B3d is None:
        _struct_B3d = struct.Struct("<B3d")
    return _struct_B3d
_struct_B6d = None
def _get_struct_B6d():
    global _struct_B6d
    if _struct_B6d is None:
        _struct_B6d = struct.Struct("<B6d")
    return _struct_B6d
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_I2B = None
def _get_struct_I2B():
    global _struct_I2B
    if _struct_I2B is None:
        _struct_I2B = struct.Struct("<I2B")
    return _struct_I2B
_struct_I9f5B = None
def _get_struct_I9f5B():
    global _struct_I9f5B
    if _struct_I9f5B is None:
        _struct_I9f5B = struct.Struct("<I9f5B")
    return _struct_I9f5B
_struct_If35d7Bb = None
def _get_struct_If35d7Bb():
    global _struct_If35d7Bb
    if _struct_If35d7Bb is None:
        _struct_If35d7Bb = struct.Struct("<If35d7Bb")
    return _struct_If35d7Bb
_struct_QI3f = None
def _get_struct_QI3f():
    global _struct_QI3f
    if _struct_QI3f is None:
        _struct_QI3f = struct.Struct("<QI3f")
    return _struct_QI3f
_struct_QIfHbB2b = None
def _get_struct_QIfHbB2b():
    global _struct_QIfHbB2b
    if _struct_QIfHbB2b is None:
        _struct_QIfHbB2b = struct.Struct("<QIfHbB2b")
    return _struct_QIfHbB2b
_struct_Qd9fHb5B = None
def _get_struct_Qd9fHb5B():
    global _struct_Qd9fHb5B
    if _struct_Qd9fHb5B is None:
        _struct_Qd9fHb5B = struct.Struct("<Qd9fHb5B")
    return _struct_Qd9fHb5B
_struct_QdI5fHBb3B = None
def _get_struct_QdI5fHBb3B():
    global _struct_QdI5fHBb3B
    if _struct_QdI5fHBb3B is None:
        _struct_QdI5fHBb3B = struct.Struct("<QdI5fHBb3B")
    return _struct_QdI5fHBb3B
_struct_d3I = None
def _get_struct_d3I():
    global _struct_d3I
    if _struct_d3I is None:
        _struct_d3I = struct.Struct("<d3I")
    return _struct_d3I
_struct_dBdB = None
def _get_struct_dBdB():
    global _struct_dBdB
    if _struct_dBdB is None:
        _struct_dBdB = struct.Struct("<dBdB")
    return _struct_dBdB
_struct_fB = None
def _get_struct_fB():
    global _struct_fB
    if _struct_fB is None:
        _struct_fB = struct.Struct("<fB")
    return _struct_fB
_struct_i2dBdBdiB = None
def _get_struct_i2dBdBdiB():
    global _struct_i2dBdBdiB
    if _struct_i2dBdBdiB is None:
        _struct_i2dBdBdiB = struct.Struct("<i2dBdBdiB")
    return _struct_i2dBdBdiB
