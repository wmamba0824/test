# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from RosAdapter/rosADToSimproEgoState.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import RosAdapter.msg

class rosADToSimproEgoState(genpy.Message):
  _md5sum = "e0da0920f294e5888d789ea87518cbc4"
  _type = "RosAdapter/rosADToSimproEgoState"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """header                            head
mil_ego_state                     egoState
csv_data                          csvData
v2x_warninginformation            v2xWarning
ad_signal_data                    adSignalData
ttc_control                       ttcControl
================================================================================
MSG: RosAdapter/header
# /** ------ Msg header ------ */
float64 u8SimTime
uint32  u4HeaderSize
uint32  u4DataSize
uint32  u4FrameNo
================================================================================
MSG: RosAdapter/mil_ego_state
# /** ------ MIL测试主车信息描述包 ------ */

object_state   sObjectState
float64        u4initSpeed
float64        u8DistRoadEnd
uint32         u4LightMask               
float32        u4WheelSpeedFL
float32        u4WheelSpeedFR
float32        u4WheelSpeedRL
float32        u4WheelSpeedRR
float32        u4MasterCylinderPressure
float32        u4WheelHeightLF
float32        u4WheelHeightLR
float32        u4WheelHeightRF
float32        u4WheelHeightRR
float32        u4SteerAngle
uint8          u1objQuantity
uint8          u1irc_id
uint8          u1irc_left_id
uint8          u1irc_right_id
uint8          u1cipv_id
uint8          u1lmc_id
uint8          u1rmc_id
uint8          u1isReachInitSpeed
================================================================================
MSG: RosAdapter/object_state
# /** ------ 对象信息 ------ */
coord           sSpeed
coord           sAccel
geometry        sGeo
coord           sPos
string          au1Name
string          au1ModelFileName
string          au1ModelName
float64[]       au8ParamScale
uint64          u8RoadId
float64         u8SpeedLimit
uint32          u4Id
float32         u4RoadS
float32         u4RoadT
float32         u4HdgRel
float32         u4LaneOffset
float32         u4TraveledDist
uint16          u2visMask
uint8           u1Type
int8            u1LaneId
uint8           u1Dir
bool            u1IsOnRoad
uint8           u1category
================================================================================
MSG: RosAdapter/coord
# /** ------ 坐标 ------ */
float64   u8X
float64   u8Y
float64   u8Z
float32   u4H
float32   u4P
float32   u4R
uint8     u1Type
================================================================================
MSG: RosAdapter/geometry
# /** ------ 几何信息 ------ */
float32 u4DimX
float32 u4DimY
float32 u4DimZ
float32 u4OffX
float32 u4OffY
float32 u4OffZ
================================================================================
MSG: RosAdapter/csv_data
# /** ------ AD发送给simpro的CSV数据 ------ */

float32  u4AccelTgt
float32  u4SteeringWheel
uint32   u4ADStatus
================================================================================
MSG: RosAdapter/v2x_warninginformation
# /** ------ V2X 告警信息 ------ */

uint32 u4Type
================================================================================
MSG: RosAdapter/ad_signal_data
string      au1SignalName
float64     u8SignalValue
================================================================================
MSG: RosAdapter/ttc_control
uint32  u4Status"""
  __slots__ = ['head','egoState','csvData','v2xWarning','adSignalData','ttcControl']
  _slot_types = ['RosAdapter/header','RosAdapter/mil_ego_state','RosAdapter/csv_data','RosAdapter/v2x_warninginformation','RosAdapter/ad_signal_data','RosAdapter/ttc_control']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       head,egoState,csvData,v2xWarning,adSignalData,ttcControl

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(rosADToSimproEgoState, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.egoState is None:
        self.egoState = RosAdapter.msg.mil_ego_state()
      if self.csvData is None:
        self.csvData = RosAdapter.msg.csv_data()
      if self.v2xWarning is None:
        self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      if self.adSignalData is None:
        self.adSignalData = RosAdapter.msg.ad_signal_data()
      if self.ttcControl is None:
        self.ttcControl = RosAdapter.msg.ttc_control()
    else:
      self.head = RosAdapter.msg.header()
      self.egoState = RosAdapter.msg.mil_ego_state()
      self.csvData = RosAdapter.msg.csv_data()
      self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      self.adSignalData = RosAdapter.msg.ad_signal_data()
      self.ttcControl = RosAdapter.msg.ttc_control()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_d3I3d3fB3d3fB6f3d3fB().pack(_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type))
      _x = self.egoState.sObjectState.au1Name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelFileName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.egoState.sObjectState.au8ParamScale)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.egoState.sObjectState.au8ParamScale))
      _x = self
      buff.write(_get_struct_QdI5fHBb3B2dI10f8B2f2I().pack(_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type))
      _x = self.adSignalData.au1SignalName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_dI().pack(_x.adSignalData.u8SignalValue, _x.ttcControl.u4Status))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.egoState is None:
        self.egoState = RosAdapter.msg.mil_ego_state()
      if self.csvData is None:
        self.csvData = RosAdapter.msg.csv_data()
      if self.v2xWarning is None:
        self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      if self.adSignalData is None:
        self.adSignalData = RosAdapter.msg.ad_signal_data()
      if self.ttcControl is None:
        self.ttcControl = RosAdapter.msg.ttc_control()
      end = 0
      _x = self
      start = end
      end += 155
      (_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type,) = _get_struct_d3I3d3fB3d3fB6f3d3fB().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1Name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1Name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelFileName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoState.sObjectState.au8ParamScale = s.unpack(str[start:end])
      _x = self
      start = end
      end += 131
      (_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type,) = _get_struct_QdI5fHBb3B2dI10f8B2f2I().unpack(str[start:end])
      self.egoState.sObjectState.u1IsOnRoad = bool(self.egoState.sObjectState.u1IsOnRoad)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.adSignalData.au1SignalName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.adSignalData.au1SignalName = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.adSignalData.u8SignalValue, _x.ttcControl.u4Status,) = _get_struct_dI().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_d3I3d3fB3d3fB6f3d3fB().pack(_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type))
      _x = self.egoState.sObjectState.au1Name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelFileName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.egoState.sObjectState.au1ModelName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.egoState.sObjectState.au8ParamScale)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.egoState.sObjectState.au8ParamScale.tostring())
      _x = self
      buff.write(_get_struct_QdI5fHBb3B2dI10f8B2f2I().pack(_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type))
      _x = self.adSignalData.au1SignalName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_dI().pack(_x.adSignalData.u8SignalValue, _x.ttcControl.u4Status))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.head is None:
        self.head = RosAdapter.msg.header()
      if self.egoState is None:
        self.egoState = RosAdapter.msg.mil_ego_state()
      if self.csvData is None:
        self.csvData = RosAdapter.msg.csv_data()
      if self.v2xWarning is None:
        self.v2xWarning = RosAdapter.msg.v2x_warninginformation()
      if self.adSignalData is None:
        self.adSignalData = RosAdapter.msg.ad_signal_data()
      if self.ttcControl is None:
        self.ttcControl = RosAdapter.msg.ttc_control()
      end = 0
      _x = self
      start = end
      end += 155
      (_x.head.u8SimTime, _x.head.u4HeaderSize, _x.head.u4DataSize, _x.head.u4FrameNo, _x.egoState.sObjectState.sSpeed.u8X, _x.egoState.sObjectState.sSpeed.u8Y, _x.egoState.sObjectState.sSpeed.u8Z, _x.egoState.sObjectState.sSpeed.u4H, _x.egoState.sObjectState.sSpeed.u4P, _x.egoState.sObjectState.sSpeed.u4R, _x.egoState.sObjectState.sSpeed.u1Type, _x.egoState.sObjectState.sAccel.u8X, _x.egoState.sObjectState.sAccel.u8Y, _x.egoState.sObjectState.sAccel.u8Z, _x.egoState.sObjectState.sAccel.u4H, _x.egoState.sObjectState.sAccel.u4P, _x.egoState.sObjectState.sAccel.u4R, _x.egoState.sObjectState.sAccel.u1Type, _x.egoState.sObjectState.sGeo.u4DimX, _x.egoState.sObjectState.sGeo.u4DimY, _x.egoState.sObjectState.sGeo.u4DimZ, _x.egoState.sObjectState.sGeo.u4OffX, _x.egoState.sObjectState.sGeo.u4OffY, _x.egoState.sObjectState.sGeo.u4OffZ, _x.egoState.sObjectState.sPos.u8X, _x.egoState.sObjectState.sPos.u8Y, _x.egoState.sObjectState.sPos.u8Z, _x.egoState.sObjectState.sPos.u4H, _x.egoState.sObjectState.sPos.u4P, _x.egoState.sObjectState.sPos.u4R, _x.egoState.sObjectState.sPos.u1Type,) = _get_struct_d3I3d3fB3d3fB6f3d3fB().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1Name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1Name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelFileName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelFileName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.egoState.sObjectState.au1ModelName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.egoState.sObjectState.au1ModelName = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.egoState.sObjectState.au8ParamScale = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      _x = self
      start = end
      end += 131
      (_x.egoState.sObjectState.u8RoadId, _x.egoState.sObjectState.u8SpeedLimit, _x.egoState.sObjectState.u4Id, _x.egoState.sObjectState.u4RoadS, _x.egoState.sObjectState.u4RoadT, _x.egoState.sObjectState.u4HdgRel, _x.egoState.sObjectState.u4LaneOffset, _x.egoState.sObjectState.u4TraveledDist, _x.egoState.sObjectState.u2visMask, _x.egoState.sObjectState.u1Type, _x.egoState.sObjectState.u1LaneId, _x.egoState.sObjectState.u1Dir, _x.egoState.sObjectState.u1IsOnRoad, _x.egoState.sObjectState.u1category, _x.egoState.u4initSpeed, _x.egoState.u8DistRoadEnd, _x.egoState.u4LightMask, _x.egoState.u4WheelSpeedFL, _x.egoState.u4WheelSpeedFR, _x.egoState.u4WheelSpeedRL, _x.egoState.u4WheelSpeedRR, _x.egoState.u4MasterCylinderPressure, _x.egoState.u4WheelHeightLF, _x.egoState.u4WheelHeightLR, _x.egoState.u4WheelHeightRF, _x.egoState.u4WheelHeightRR, _x.egoState.u4SteerAngle, _x.egoState.u1objQuantity, _x.egoState.u1irc_id, _x.egoState.u1irc_left_id, _x.egoState.u1irc_right_id, _x.egoState.u1cipv_id, _x.egoState.u1lmc_id, _x.egoState.u1rmc_id, _x.egoState.u1isReachInitSpeed, _x.csvData.u4AccelTgt, _x.csvData.u4SteeringWheel, _x.csvData.u4ADStatus, _x.v2xWarning.u4Type,) = _get_struct_QdI5fHBb3B2dI10f8B2f2I().unpack(str[start:end])
      self.egoState.sObjectState.u1IsOnRoad = bool(self.egoState.sObjectState.u1IsOnRoad)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.adSignalData.au1SignalName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.adSignalData.au1SignalName = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.adSignalData.u8SignalValue, _x.ttcControl.u4Status,) = _get_struct_dI().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_QdI5fHBb3B2dI10f8B2f2I = None
def _get_struct_QdI5fHBb3B2dI10f8B2f2I():
    global _struct_QdI5fHBb3B2dI10f8B2f2I
    if _struct_QdI5fHBb3B2dI10f8B2f2I is None:
        _struct_QdI5fHBb3B2dI10f8B2f2I = struct.Struct("<QdI5fHBb3B2dI10f8B2f2I")
    return _struct_QdI5fHBb3B2dI10f8B2f2I
_struct_d3I3d3fB3d3fB6f3d3fB = None
def _get_struct_d3I3d3fB3d3fB6f3d3fB():
    global _struct_d3I3d3fB3d3fB6f3d3fB
    if _struct_d3I3d3fB3d3fB6f3d3fB is None:
        _struct_d3I3d3fB3d3fB6f3d3fB = struct.Struct("<d3I3d3fB3d3fB6f3d3fB")
    return _struct_d3I3d3fB3d3fB6f3d3fB
_struct_dI = None
def _get_struct_dI():
    global _struct_dI
    if _struct_dI is None:
        _struct_dI = struct.Struct("<dI")
    return _struct_dI
